C51 COMPILER V7.20   EZMACPRO_TIMERINT                                                     04/10/2014 16:48:40 PAGE 1   


C51 COMPILER V7.20, COMPILATION OF MODULE EZMACPRO_TIMERINT
OBJECT MODULE PLACED IN EZMacPro_TimerInt.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\c51.exe EZMacPro_TimerInt.c DB OE BR DF(SI1000MB_SI1000,FREQUENCY_BAND_434,TRANSCEI
                    -VER_OPERATION,FOUR_CHANNEL_IS_USED,EXTENDED_PACKET_FORMAT,TRACE_ENABLED) INCDIR(..\..\bsp;..\..\stack;c:\SiLabs\MCU_3\In
                    -c)

line level    source

   1          /*!\file EZMacPro_TimerInt.c
   2           * \brief Timer interrupt triggered state machine and functions.
   3           *
   4           * \n EZMacPRO version: 3.0.1r
   5           *
   6           * \n This software must be used in accordance with the End User License
   7           * \n Agreement.
   8           *
   9           * \b COPYRIGHT
  10           * \n Copyright 2012 Silicon Laboratories, Inc.
  11           * \n http://www.silabs.com
  12           */
  13          
  14                          /* ======================================= *
  15                           *              I N C L U D E              *
  16                           * ======================================= */
  17          
  18          #include "stack.h"
  19          
  20          
  21                          /* ======================================= *
  22                           *     G L O B A L   V A R I A B L E S     *
  23                           * ======================================= */
  24          
  25          SEGMENT_VARIABLE(ChannelOccupiedInStartPeriod, U8, EZMAC_PRO_GLOBAL_MSPACE);
  26          SEGMENT_VARIABLE(ChannelOccupiedCounter, U8, EZMAC_PRO_GLOBAL_MSPACE);
  27          
  28          
  29                          /* ======================================= *
  30                           *      L O C A L   F U N C T I O N S      *
  31                           * ======================================= */
  32          
  33          //------------------------------------------------------------------------------------------------
  34          // Function Name
  35          //    timerIntT0_ISR()
  36          //
  37          // Return Value : None
  38          // Parameters   : None
  39          //
  40          // This is the Interrupt Service Routing for the T0 timer. The T0 timer is used for all MAC
  41          // time outs and MAC timing events. The T0 time base uses SYSCLK/4 for all supported SYSCLK
  42          // frequencies. The time outs are calculated using macros or calculated by the initialization
  43          // or register write API functions. Since some time outs require long periods a 24-bit timer
  44          // has been implemented using a global variable for the most significant byte. If the MSB of the
  45          // timer (EZMacProTimerMSB) is non-zero, it will be decrement and the ISR will be called again
  46          // when the timer overflows.
  47          //
  48          // This function disables the timer interrupts before executing the state machines. If a
  49          // timeout event is to initiate another timeout event, the timerIntTimeout() function should
  50          // be used.
  51          //
  52          // The Basic States (Wake-up, Receive, and Transmit) are implemented using if..else if bit
  53          // tests for the corresponding bit in the master control register. The detailed TX and RX
C51 COMPILER V7.20   EZMACPRO_TIMERINT                                                     04/10/2014 16:48:40 PAGE 2   

  54          // state machines are implemented in separate functions.
  55          //
  56          // Conditional compile time switches remove the TX or RX state machines for the RX only and
  57          // and TX only builds.
  58          //
  59          // The timer interrupt should not call functions from other modules. This would create cause
  60          // a multiple call to segment warning and result in poor RAM usage.
  61          //
  62          //-----------------------------------------------------------------------------------------------
  63          INTERRUPT(timerIntT3_ISR, INTERRUPT_TIMER3)
  64          {
  65   1          U8 state;
  66   1      
  67   1          if (EZMacProTimerMSB == 0)
  68   1          {
  69   2              DISABLE_MAC_TIMER_INTERRUPT();
  70   2              STOP_MAC_TIMER();
  71   2              CLEAR_MAC_TIMER_INTERRUPT();
  72   2      
  73   2              state = EZMacProReg.name.MSR & 0x0F;
  74   2      
  75   2              if (EZMacProReg.name.MSR == EZMAC_PRO_WAKE_UP)
  76   2              {//if the MAC is in Wake up state call the WakeUp function
  77   3                  timerIntWakeUp();
  78   3              }
  79   2      #ifndef RECEIVER_ONLY_OPERATION
  80   2              else if ((EZMacProReg.name.MSR & TX_STATE_BIT) == TX_STATE_BIT)
  81   2              {//if the MAC is in transmit state then call the transmit state machine
  82   3                  timerIntTX_StateMachine(state);
  83   3              }
  84   2      #endif
  85   2      #ifndef TRANSMITTER_ONLY_OPERATION
  86   2              else if ((EZMacProReg.name.MSR & RX_STATE_BIT) == RX_STATE_BIT)
  87   2              {//if the MAC is in receive state then call the receiver
  88   3                  timerIntRX_StateMachine(state);
  89   3              }
  90   2      #endif
  91   2              else
  92   2              {
  93   3              }
  94   2          }
  95   1          else
  96   1          {
  97   2              CLEAR_MAC_TIMER_INTERRUPT();
  98   2              EZMacProTimerMSB--;
  99   2          }
 100   1      }
 101          //------------------------------------------------------------------------------------------------
 102          // Function Name
 103          //    timerIntWakeUp()
 104          //
 105          // Return Value : None
 106          // Parameters   : None
 107          //
 108          // The EZMAC_PRO_WAKE_UP state is used when starting the radio XTAL after sleep mode or when
 109          // resetting the radio using a SW Reset SPI command.
 110          //
 111          // If this function is called, the crystal has failed to start with the specified time. This
 112          // indicates are hardware problem. Either the crystal is not connect, the SDN/ is asserted,
 113          // or the radio is not powered.
 114          //
 115          //-----------------------------------------------------------------------------------------------
C51 COMPILER V7.20   EZMACPRO_TIMERINT                                                     04/10/2014 16:48:40 PAGE 3   

 116          void timerIntWakeUp (void)
 117          {
 118   1         // SWRESET timeout error
 119   1         DISABLE_MAC_INTERRUPTS();
 120   1              //go to WAKE UP ERROR state
 121   1         EZMacProReg.name.MSR = WAKE_UP_ERROR;
 122   1         //call the error state entered callback function
 123   1         EZMacPRO_StateErrorEntered();
 124   1      }
 125          //------------------------------------------------------------------------------------------------
 126          // Function Name
 127          //    timerIntTX_StateMachine()
 128          //
 129          // Return Value : None
 130          // Parameters   : U8 state - TX state, least significant nibble of MSR
 131          //
 132          // This function implements the detailed TX state machine. The state machine is implemented
 133          // using switch...case... statements. For efficient compilation, the states are a series
 134          // of sequential continuous integers (no missing values). The states are enumerated in the
 135          // EZMacPro.h header file.
 136          //
 137          // Conditional compile time switches remove the unused TX states if LBT of ACK is not supported.
 138          // These states are also removed from the enumeration at the begriming or end of the list.
 139          //
 140          // Conditional compile time switches remove this entire function for the Receiver only build.
 141          //
 142          //-----------------------------------------------------------------------------------------------
 143          #ifndef RECEIVER_ONLY_OPERATION
 144          void timerIntTX_StateMachine (U8 state)
 145          {
 146   1      
 147   1      #ifdef TRANSCEIVER_OPERATION
 148   1         U32 timeout;
 149   1      #endif//TRANSCEIVER_OPERATION
 150   1      
 151   1      
 152   1      #ifdef ANTENNA_DIVERSITY_ENABLED
              #ifndef B1_ONLY
                      U8 temp8;
              #endif//B1_ONLY
              #endif//ANTENNA_DIVERSITY_ENABLED
 157   1      
 158   1         switch (state)
 159   1         {
 160   2      #ifdef TRANSCEIVER_OPERATION
 161   2            case TX_STATE_LBT_START_LISTEN:
 162   2                              if(BusyLBT == 0)
 163   2                              {//the channel was free during the first 0.5ms
 164   3                                      ChannelOccupiedInStartPeriod = 0;
 165   3                  // start timer with fix 4.5ms timeout
 166   3                                      timerIntTimeout(LBT_FIXED_TIME_4500US);
 167   3                                      // go to the next state
 168   3                  EZMacProReg.name.MSR = TX_STATE_BIT | TX_STATE_LBT_LISTEN;
 169   3                              // disable the reciever
 170   3                              timerIntSetFunction1(SI4432_XTON);
 171   3                              // enable the receiver again
 172   3                              timerIntSetFunction1( SI4432_RXON|SI4432_XTON);
 173   3      
 174   3                                      ENABLE_MAC_TIMER_INTERRUPT();
 175   3                              }
 176   2                              else
 177   2                              {//the channnel was busy during the first 0.5ms
C51 COMPILER V7.20   EZMACPRO_TIMERINT                                                     04/10/2014 16:48:40 PAGE 4   

 178   3                                      BusyLBT = 0;
 179   3                                      ChannelOccupiedInStartPeriod = 1;
 180   3                                      ChannelOccupiedCounter = 0;
 181   3                  // start timer with fix 1ms timeout
 182   3                  timerIntTimeout(LBT_FIXED_TIME_1000US);
 183   3                                      //go to the next state
 184   3                  EZMacProReg.name.MSR = TX_STATE_BIT | TX_STATE_LBT_LISTEN;
 185   3                              // disable the reciever
 186   3                              timerIntSetFunction1(SI4432_XTON);
 187   3                              // enable the receiver again
 188   3                              timerIntSetFunction1( SI4432_RXON|SI4432_XTON);
 189   3                                      ENABLE_MAC_TIMER_INTERRUPT();
 190   3                              }
 191   2                              break;
 192   2      
 193   2      
 194   2                      case TX_STATE_LBT_LISTEN:
 195   2               if (ChannelOccupiedInStartPeriod == 0)
 196   2                              {//the channel was free during the 0.5ms start period
 197   3      
 198   3                       if(BusyLBT == 0)
 199   3                       {// LBT passed, channel should be clear in the fix 4.5ms period
 200   4                                              //disable the receiver
 201   4                          timerIntSetFunction1(SI4432_XTON);
 202   4                                              // clear enable 2 interrupt
 203   4                          timerIntSetEnable2(0x00);
 204   4                          // enable ENPKSENT bit
 205   4                          timerIntSpiWriteReg(SI4432_INTERRUPT_ENABLE_1, SI4432_ENPKSENT);
 206   4                          // enable TX
 207   4                          timerIntSetFunction1( SI4432_TXON|SI4432_XTON);
 208   4                     // start timer with transmit packet timeout
 209   4                                              timerIntTimeout(TimeoutTX_Packet);
 210   4                                              //go to the next state
 211   4                          EZMacProReg.name.MSR = TX_STATE_BIT | TX_STATE_WAIT_FOR_TX;
 212   4                          ENABLE_MAC_TIMER_INTERRUPT();
 213   4                       }
 214   3                              else
 215   3                                      {//the channel was busy during the 4.5ms
 216   4                                              BusyLBT = 0;
 217   4                                              // multiple by fixed plus random number
 218   4                      timeout = LBT_FIXED_TIME_5000US + TimeoutLBTI * (U32)(timerIntRandom());
 219   4                     // start timer with timeout
 220   4                      timerIntTimeout(timeout);
 221   4                                              //go to the next state
 222   4                               EZMacProReg.name.MSR = TX_STATE_BIT | TX_STATE_LBT_RANDOM_LISTEN;
 223   4                              // disable the reciever
 224   4                                      timerIntSetFunction1(SI4432_XTON);
 225   4                                      // enable the receiver again
 226   4                                      timerIntSetFunction1( SI4432_RXON|SI4432_XTON);
 227   4                                              ENABLE_MAC_TIMER_INTERRUPT();
 228   4                                      }
 229   3                              }
 230   2                              else
 231   2                              {//the channel was busy during the 0.5ms start period
 232   3                                 if(BusyLBT == 0)
 233   3                       {// LBT passed, channel should be clear in the fix 1ms period
 234   4                      // multiple by fixed plus random number
 235   4                      timeout = LBT_FIXED_TIME_5000US + TimeoutLBTI * (U32)(timerIntRandom());
 236   4                     // start timer with timeout
 237   4                      timerIntTimeout(timeout);
 238   4                                              //go to the next state
 239   4                               EZMacProReg.name.MSR = TX_STATE_BIT | TX_STATE_LBT_RANDOM_LISTEN;
C51 COMPILER V7.20   EZMACPRO_TIMERINT                                                     04/10/2014 16:48:40 PAGE 5   

 240   4                         ENABLE_MAC_TIMER_INTERRUPT();
 241   4                       }
 242   3                                      else
 243   3                                      {//the channel was busy in the fix 1ms period
 244   4                                              if (ChannelOccupiedCounter < 9)
 245   4                                              {
 246   5                                                      BusyLBT = 0;
 247   5                              ChannelOccupiedCounter++;
 248   5                             // start timer with fix 1ms timeout
 249   5                      timerIntTimeout(LBT_FIXED_TIME_1000US);
 250   5                                                      // go to the next state
 251   5                              EZMacProReg.name.MSR = TX_STATE_BIT | TX_STATE_LBT_LISTEN;
 252   5                              // disable the reciever
 253   5                                              timerIntSetFunction1(SI4432_XTON);
 254   5                                              // enable the receiver again
 255   5                                              timerIntSetFunction1( SI4432_RXON|SI4432_XTON);
 256   5                                                      ENABLE_MAC_TIMER_INTERRUPT();
 257   5                                              }
 258   4                                              else
 259   4                                              {//the channel was busy during the 10*1ms
 260   5                                                      BusyLBT = 0;
 261   5                                                      EZMacProLBT_Retrys++;
 262   5                                                      if(EZMacProLBT_Retrys < MAX_LBT_RETRIES)
 263   5                                      {//the channel was busy and the retries didn't reach the maximum value
 264   6                                      // disable the reciever
 265   6                                      timerIntSetFunction1(SI4432_XTON);
 266   6                                      // start timer with fix ETSI timeout
 267   6                                      timerIntTimeout(TIMEOUT_LBTI_ETSI);
 268   6                                                              // go to the next state
 269   6                                      EZMacProReg.name.MSR = TX_STATE_BIT | TX_STATE_LBT_START_LISTEN;
 270   6                                      ENABLE_MAC_TIMER_INTERRUPT();
 271   6                                      // enable the receiver again
 272   6                                      timerIntSetFunction1( SI4432_RXON|SI4432_XTON);
 273   6                                      }
 274   5                                      else
 275   5                                      {//the channel was busy and the retries reach the maximum value
 276   6                                              //DISABLE_MAC_INTERRUPTS();
 277   6                                              //disable the receiver
 278   6                                      timerIntSetFunction1(SI4432_XTON);
 279   6                                                              //go to the next state
 280   6                                      EZMacProReg.name.MSR = TX_STATE_BIT | TX_ERROR_CHANNEL_BUSY;
 281   6      #ifdef FOUR_CHANNEL_IS_USED
 282   6                                                              //increment error counter
 283   6                                      timerIntIncrementError(EZMAC_PRO_ERROR_CHANNEL_BUSY);
 284   6      #endif //FOUR_CHANNEL_IS_USED
 285   6                                                              //call the LBT error callback function
 286   6                                      EZMacPRO_LBTTimeout();
 287   6                                      }
 288   5                                              }
 289   4                                      }
 290   3      
 291   3                              }
 292   2                              break;
 293   2      
 294   2                      case TX_STATE_LBT_RANDOM_LISTEN:
 295   2                                      if(BusyLBT == 0)
 296   2                                      {// the channel was free during the 5ms + random period
 297   3                                              //disable the receiver
 298   3                          timerIntSetFunction1(SI4432_XTON);
 299   3                                              // clear enable 2 interrupt
 300   3                          timerIntSetEnable2(0x00);
 301   3                          // enable ENPKSENT bit
C51 COMPILER V7.20   EZMACPRO_TIMERINT                                                     04/10/2014 16:48:40 PAGE 6   

 302   3                          timerIntSpiWriteReg(SI4432_INTERRUPT_ENABLE_1, SI4432_ENPKSENT);
 303   3                          // enable TX
 304   3                          timerIntSetFunction1( SI4432_TXON|SI4432_XTON);
 305   3                          // start timer with transmit packet timeout
 306   3                          timerIntTimeout(TimeoutTX_Packet);
 307   3                                              //go to the next state
 308   3                          EZMacProReg.name.MSR = TX_STATE_BIT | TX_STATE_WAIT_FOR_TX;
 309   3                          ENABLE_MAC_TIMER_INTERRUPT();
 310   3                                      }
 311   2                                      else
 312   2                                      {//the channel was busy during the 5ms + random period
 313   3                                              BusyLBT = 0;
 314   3                                              EZMacProLBT_Retrys++;
 315   3                                              if(EZMacProLBT_Retrys < MAX_LBT_RETRIES)
 316   3                              {//the channel was busy and the retries didn't reach the maximum value
 317   4                              // disable the reciever
 318   4                              timerIntSetFunction1(SI4432_XTON);
 319   4                              // start timer with fix ETSI timeout
 320   4                              timerIntTimeout(TIMEOUT_LBTI_ETSI);
 321   4                                                      // go to the next state
 322   4                              EZMacProReg.name.MSR = TX_STATE_BIT | TX_STATE_LBT_START_LISTEN;
 323   4                              ENABLE_MAC_TIMER_INTERRUPT();
 324   4                              // enable the receiver again
 325   4                              timerIntSetFunction1( SI4432_RXON|SI4432_XTON);
 326   4                              }
 327   3                              else
 328   3                              {//the channel was busy and the retries reach the maximum value
 329   4                                      //disable the receiver
 330   4                              timerIntSetFunction1(SI4432_XTON);
 331   4                                                      //go to the next state
 332   4                              EZMacProReg.name.MSR = TX_STATE_BIT | TX_ERROR_CHANNEL_BUSY;
 333   4      #ifdef FOUR_CHANNEL_IS_USED
 334   4                                                      //increment error counter
 335   4                                                      timerIntIncrementError(EZMAC_PRO_ERROR_CHANNEL_BUSY);
 336   4      #endif //FOUR_CHANNEL_IS_USED
 337   4                                                      //call LBT error callback function
 338   4                                              EZMacPRO_LBTTimeout();
 339   4                              }
 340   3      
 341   3                                      }
 342   2      
 343   2                              break;
 344   2      
 345   2      #endif//TRANSCEIVER_OPERATION
 346   2      
 347   2            case TX_STATE_WAIT_FOR_TX:
 348   2      
 349   2               // TX transmit error - no ipksent interrupt before timeout
 350   2               // This indicates a problem with the hardware or timeout
 351   2                              //if there is a TX error then switch back the internal antenna diversity algorthm
 352   2      #ifdef ANTENNA_DIVERSITY_ENABLED
              #ifndef B1_ONLY
                                      //if revision V2 or A0 chip is used
                                      if ((EZMacProReg.name.DTR == 0x00) || (EZMacProReg.name.DTR == 0x01))
                                      {
              
                                              //switch ON the internal algorithm
                                              temp8 = timerIntSpiReadReg(SI4432_OPERATING_AND_FUNCTION_CONTROL_2);
                                              timerIntSpiWriteReg (SI4432_OPERATING_AND_FUNCTION_CONTROL_2, temp8 | 0x80);
                                              //the gpios control the rf chip automatically
                                              timerIntSpiWriteReg(SI4432_GPIO1_CONFIGURATION, 0x17);
                                              timerIntSpiWriteReg(SI4432_GPIO2_CONFIGURATION, 0x18);
C51 COMPILER V7.20   EZMACPRO_TIMERINT                                                     04/10/2014 16:48:40 PAGE 7   

                                      }
              #endif//B1_ONLY
              #endif//ANTENNA_DIVERSITY_ENABLED
 367   2      //                      DISABLE_MAC_INTERRUPTS();        // clear EX0 & ET0
 368   2      //            STOP_MAC_TIMER();                // stop Timer
 369   2      //            CLEAR_MAC_TIMER_INTERRUPT();     // clear flag
 370   2      //            CLEAR_MAC_EXT_INTERRUPT();
 371   2                              //go to the TX ERROR STATE
 372   2               EZMacProReg.name.MSR = TX_STATE_BIT | TX_ERROR_STATE;
 373   2               //Call the Error state entered callback.
 374   2               EZMacPRO_StateErrorEntered();
 375   2               break;
 376   2      
 377   2      #ifdef EXTENDED_PACKET_FORMAT
 378   2      //#ifndef TRANSMITTER_ONLY_OPERATION
 379   2      #ifdef TRANSCEIVER_OPERATION
 380   2            case TX_STATE_WAIT_FOR_ACK:
 381   2                DISABLE_MAC_INTERRUPTS();        // clear EX0 & ET0
 382   2                              //disbale the interrupts
 383   2               timerIntSpiWriteReg( SI4432_INTERRUPT_ENABLE_1, 0x00);
 384   2               timerIntSetEnable2(0x00);
 385   2               //clear interrupts
 386   2               timerIntSpiReadReg(SI4432_INTERRUPT_STATUS_1);
 387   2               timerIntSpiReadReg(SI4432_INTERRUPT_STATUS_2);
 388   2               //disable the receiver
 389   2               timerIntSetFunction1(SI4432_XTON);
 390   2      //                      //go to TX ERROR NO ACK state
 391   2      //         EZMacProReg.name.MSR = TX_STATE_BIT | TX_ERROR_NO_ACK;
 392   2               //call the no ack callback function
 393   2               EZMacPRO_AckTimeout();
 394   2               // all done use SECR to determine next state
 395   2               timerIntGotoNextStateUsingSECR(1);
 396   2               break;
 397   2      //#endif//TRANSMITTER_ONLY_OPERATION
 398   2      #endif//TRANSCEIVER_OPERATION
 399   2      #endif//EXTENDED_PACKET_FORMAT
 400   2            case TX_ERROR_STATE:
 401   2               DISABLE_MAC_INTERRUPTS();        // clear EX0 & ET0
 402   2               // disable all Si443x interrupt sources
 403   2               timerIntSpiWriteReg(SI4432_INTERRUPT_ENABLE_1, 0x00);
 404   2               timerIntSetEnable2(0x00);
 405   2                // clear interrupts
 406   2               timerIntSpiReadReg(SI4432_INTERRUPT_STATUS_1);
 407   2               timerIntSpiReadReg(SI4432_INTERRUPT_STATUS_2);
 408   2               STOP_MAC_TIMER();                // stop Timer
 409   2               CLEAR_MAC_TIMER_INTERRUPT();     // clear flag
 410   2               CLEAR_MAC_EXT_INTERRUPT();
 411   2      #ifndef B1_ONLY
                                      if(EZMacProReg.name.DTR == 0)//if rev V2 chip is used
                                    // this register setting is need for good current consumption in Idle mode (only rev V2)
                            timerIntSpiWriteReg (SI4432_CRYSTAL_OSCILLATOR_CONTROL_TEST, SI4432_BUFOVR);
              #endif
 416   2               break;
 417   2      #ifdef TRANSCEIVER_OPERATION
 418   2                      case TX_ERROR_CHANNEL_BUSY:
 419   2                              break;
 420   2      #endif //TRANSCEIVER_OPERATION
 421   2        } // end switch
 422   1      }
 423          #endif // RECEIVER_ONLY_OPERATION not defined
 424          //------------------------------------------------------------------------------------------------
 425          // Function Name
C51 COMPILER V7.20   EZMACPRO_TIMERINT                                                     04/10/2014 16:48:40 PAGE 8   

 426          //    timerIntRX_StateMachine()
 427          //
 428          // Return Value : None
 429          // Parameters   : U8 state - RX state, least significant nibbble of MSR
 430          //
 431          // This function implements the detailed RX state machine. The state machine is implemented
 432          // using switch...case... statements. For efficient compilation, the states are a series
 433          // of sequential continuous integers (no missing values). The states are enumerated in the
 434          // EZMacPro.h header file.
 435          //
 436          // Conditional compile time switches remove the unused RX states if LBT, ACK, or packet
 437          // forwarding is not supported. These states are also removed from the enumeration at the
 438          // begriming or end of the list.
 439          //
 440          // Conditional compile time switches remove this entire function for the Transmitter only build.
 441          //
 442          //-----------------------------------------------------------------------------------------------
 443          #ifndef TRANSMITTER_ONLY_OPERATION
 444          void timerIntRX_StateMachine (U8 state)
 445          {
 446   1              U8 temp8;
 447   1      #ifdef   PACKET_FORWARDING_SUPPORTED
                 U32 timeout;
              #endif//PACKET_FORWARDING_SUPPORTED
 450   1         switch (state)
 451   1         {
 452   2      #ifdef FOUR_CHANNEL_IS_USED
 453   2            case RX_STATE_FREQUENCY_SEARCH:
 454   2               // jump to the next channel if search mechanism is enabled
 455   2               if((EZMacProReg.name.RCR & 0x04) == 0x04)
 456   2               {
 457   3                         timerIntNextRX_Channel();
 458   3               }
 459   2                              // start timer with channel search timeout
 460   2               timerIntTimeout(TimeoutChannelSearch);
 461   2               ENABLE_MAC_TIMER_INTERRUPT();
 462   2                              break;
 463   2      #endif //FOUR_CHANNEL_IS_USED
 464   2      
 465   2      #ifdef MORE_CHANNEL_IS_USED
                              case RX_STATE_FREQUENCY_SEARCH:
                                      //check the channel number
                                      if (SelectedChannel < (maxChannelNumber - 1))
                                      {
                                              //jump to the next channel
                                              SelectedChannel++;
                                              //switch off the receiver
                                              timerIntSetFunction1(SI4432_XTON);
                                              timerIntSpiWriteReg (SI4432_FREQUENCY_HOPPING_CHANNEL_SELECT,EZMacProReg.array[FR0+SelectedChannel])
             -;
                                              //switch on the receiver
                                              timerIntSetFunction1(SI4432_XTON|SI4432_RXON);
                                              // start timer with channel search timeout
                                              timerIntTimeout(TimeoutChannelSearch);
                                              ENABLE_MAC_TIMER_INTERRUPT();
                                      }
                                      else
                                      {
                                              //jump to the first channel
                                              SelectedChannel = 0;
                                              //switch off the receiver
                                         timerIntSetFunction1(SI4432_XTON);
C51 COMPILER V7.20   EZMACPRO_TIMERINT                                                     04/10/2014 16:48:40 PAGE 9   

                                              timerIntSpiWriteReg (SI4432_FREQUENCY_HOPPING_CHANNEL_SELECT,EZMacProReg.array[FR0+SelectedChannel]);
                                              //switch on the receiver
                                              timerIntSetFunction1(SI4432_XTON|SI4432_RXON);
                                              // start timer with channel search timeout
                                      timerIntTimeout(TimeoutChannelSearch);
                                      ENABLE_MAC_TIMER_INTERRUPT();
                                      }
                                      break;
              #endif//MORE_CHANNEL_IS_USED
 496   2      
 497   2      
 498   2                      case RX_STATE_WAIT_FOR_PACKET:
 499   2                              //set the dinamic plength if it is needed otherwise set the fix length
 500   2                         if ((EZMacProReg.name.MCR & 0x04) == 0x04)
 501   2                              {
 502   3                                      temp8 = timerIntSpiReadReg(SI4432_HEADER_CONTROL_2);
 503   3                                      temp8 &= ~0x08;
 504   3                                      timerIntSpiWriteReg(SI4432_HEADER_CONTROL_2, temp8);
 505   3                              }
 506   2                              else
 507   2                              {
 508   3                                      timerIntSpiWriteReg(SI4432_TRANSMIT_PACKET_LENGTH, EZMacProReg.name.PLEN);
 509   3                              }
 510   2      
 511   2      #ifdef MORE_CHANNEL_IS_USED
                    case RX_STATE_WAIT_FOR_PREAMBLE:
              #endif//MORE_CHANNEL_IS_USED
 514   2      
 515   2            case RX_STATE_WAIT_FOR_SYNC:
 516   2               // RX error - HW error or bad timeout calculation
 517   2               //switch off the receiver
 518   2               timerIntSetFunction1(SI4432_XTON);
 519   2               // clear interrupt enable 1
 520   2               timerIntSpiWriteReg(SI4432_INTERRUPT_ENABLE_1, 0x00);
 521   2      #ifdef FOUR_CHANNEL_IS_USED
 522   2               //Enable the Preamble valid interrupt
 523   2               timerIntSetEnable2(SI4432_ENPREAVAL);
 524   2               // jump to the next channel if search mechanism is enabled
 525   2               if((EZMacProReg.name.RCR & 0x04) == 0x04)
 526   2               {
 527   3                  timerIntNextRX_Channel();
 528   3               }
 529   2                              // start timer with channel search timeout
 530   2               timerIntTimeout(TimeoutChannelSearch);
 531   2               ENABLE_MAC_TIMER_INTERRUPT();
 532   2      
 533   2      #endif//FOUR_CHANNEL_IS_USED
 534   2      
 535   2      #ifdef MORE_CHANNEL_IS_USED
                              //enable the preamble valid interrupt
                              timerIntSetEnable2(SI4432_ENPREAVAL);
                                      //determine the next channel number
                                      if (SelectedChannel < (maxChannelNumber - 1))
                                      {
                                              SelectedChannel++;
                                      }
                                      else
                                      {
                                              SelectedChannel = 0;
                                      }
                                      //jump to the next channel
                                      timerIntSpiWriteReg (SI4432_FREQUENCY_HOPPING_CHANNEL_SELECT,EZMacProReg.array[FR0+SelectedChannel]);
C51 COMPILER V7.20   EZMACPRO_TIMERINT                                                     04/10/2014 16:48:40 PAGE 10  

                                      // start timer with channel search timeout
                                      timerIntTimeout(TimeoutChannelSearch);
                       ENABLE_MAC_TIMER_INTERRUPT();
              
              #endif//MORE_CHANNEL_IS_USED
 554   2                              //enable the receiver
 555   2               timerIntSetFunction1(SI4432_RXON|SI4432_XTON);
 556   2                              //go to the next channel
 557   2               EZMacProReg.name.MSR = RX_STATE_BIT | RX_STATE_FREQUENCY_SEARCH;
 558   2               break;
 559   2      
 560   2      #ifdef EXTENDED_PACKET_FORMAT
 561   2      #ifndef RECEIVER_ONLY_OPERATION
 562   2            case RX_STATE_WAIT_FOR_SEND_ACK:
 563   2               // SW error
 564   2      #ifdef ANTENNA_DIVERSITY_ENABLED
              #ifndef B1_ONLY
                                      //if revision V2 or A0 chip is used
                                      if ((EZMacProReg.name.DTR == 0x00) || (EZMacProReg.name.DTR == 0x01))
                                      {
                                              //switch ON the internal algorithm
                                              temp8 = timerIntSpiReadReg(SI4432_OPERATING_AND_FUNCTION_CONTROL_2);
                                              timerIntSpiWriteReg (SI4432_OPERATING_AND_FUNCTION_CONTROL_2, temp8 | 0x80);
                                              //the gpios control the rf chip automatically
                                              timerIntSpiWriteReg(SI4432_GPIO1_CONFIGURATION, 0x17);
                                              timerIntSpiWriteReg(SI4432_GPIO2_CONFIGURATION, 0x18);
                                      }
              #endif//B1_ONLY
              #endif//ANTENNA_DIVERSITY_ENABLED
 578   2      #ifndef PACKET_FORWARDING_SUPPORTED
 579   2                              //set back the preamble length
 580   2      #ifdef FOUR_CHANNEL_IS_USED
 581   2              timerIntSpiWriteReg(SI4432_PREAMBLE_LENGTH, PreamRegValue);
 582   2      #endif//FOUR_CHANNEL_IS_USED
 583   2      #ifdef MORE_CHANNEL_IS_USED
                                      temp8 = timerIntSpiReadReg(SI4432_HEADER_CONTROL_2);
                                      timerIntSpiWriteReg(SI4432_HEADER_CONTROL_2, (temp8 | 0x01));
                      timerIntSpiWriteReg(SI4432_PREAMBLE_LENGTH, PreamRegValue);
              #endif//MORE_CHANNEL_IS_USED
 588   2      #endif//PACKET_FORWARDING_SUPPORTED
 589   2                              //go to the RX ERROR STATE
 590   2               EZMacProReg.name.MSR = (RX_STATE_BIT | RX_ERROR_STATE);
 591   2               //Call the Error state entered callback.
 592   2               EZMacPRO_StateErrorEntered();
 593   2               break;
 594   2      #endif//RECEIVER_ONLY_OPERATION
 595   2      #endif//EXTENDED_PACKET_FORMAT
 596   2      
 597   2      #ifdef   PACKET_FORWARDING_SUPPORTED
              #ifdef   TRANSCEIVER_OPERATION
                    case RX_STATE_FORWARDING_LBT_START_LISTEN:
                                      if(BusyLBT == 0)
                                      {//the channel was free during the first 0.5ms
                                              ChannelOccupiedInStartPeriod = 0;
                          // start timer with fix 4.5ms timeout
                          timerIntTimeout(LBT_FIXED_TIME_4500US);
                                              //go to the next state
                          EZMacProReg.name.MSR = RX_STATE_BIT | RX_STATE_FORWARDING_LBT_LISTEN;
                                              // disable the receiver
                                      timerIntSetFunction1(SI4432_XTON);
                                      // enable the receiver again
                                      timerIntSetFunction1( SI4432_RXON|SI4432_XTON);
C51 COMPILER V7.20   EZMACPRO_TIMERINT                                                     04/10/2014 16:48:40 PAGE 11  

                                              ENABLE_MAC_TIMER_INTERRUPT();
                                      }
                                      else
                                      {//the channnel was busy during the first 0.5ms
                                              BusyLBT = 0;
                                              ChannelOccupiedInStartPeriod = 1;
                                              ChannelOccupiedCounter = 0;
                               // start timer with fix 1ms timeout
                          timerIntTimeout(LBT_FIXED_TIME_1000US);
                                              // go to the next state
                          EZMacProReg.name.MSR = RX_STATE_BIT | RX_STATE_FORWARDING_LBT_LISTEN;
                                              // disable the receiver
                                      timerIntSetFunction1(SI4432_XTON);
                                      // enable the receiver again
                                      timerIntSetFunction1( SI4432_RXON|SI4432_XTON);
                                              ENABLE_MAC_TIMER_INTERRUPT();
                                      }
                                      break;
              
              
                              case RX_STATE_FORWARDING_LBT_LISTEN:
                       if (ChannelOccupiedInStartPeriod == 0)
                                      {//the channel was free during the 0.5ms start period
              
                               if(BusyLBT == 0)
                               {// LBT passed, channel should be clear in the fix 4.5ms period
                                                      //disable the receiver
                                  timerIntSetFunction1(SI4432_XTON);
                                                      // clear enable 2 interrupt
                                  timerIntSetEnable2(0x00);
                                  // enable ENPKSENT bit
                                  timerIntSpiWriteReg(SI4432_INTERRUPT_ENABLE_1, SI4432_ENPKSENT);
                                  // enable TX
                                  timerIntSetFunction1( SI4432_TXON|SI4432_XTON);
                                  // start timer with packet transmit timeout
                                  timerIntTimeout(TimeoutTX_Packet);
                                                      //go to the next state
                                  EZMacProReg.name.MSR = RX_STATE_BIT | RX_STATE_FORWARDING_WAIT_FOR_TX;
                                  ENABLE_MAC_TIMER_INTERRUPT();
                               }
                                      else
                                              {//the channel was busy during the 4.5ms
                                                      BusyLBT = 0;
                                                      // multiple by fixed plus random number
                              timeout = LBT_FIXED_TIME_5000US + TimeoutLBTI * (U32)(timerIntRandom());
                              // start timer with timeout
                              timerIntTimeout(timeout);
                                                      //got to the next state
                                       EZMacProReg.name.MSR = RX_STATE_BIT | RX_STATE_FORWARDING_LBT_RANDOM_LISTEN;
              
                                                      // disable the receiver
                                              timerIntSetFunction1(SI4432_XTON);
                                              // enable the receiver again
                                              timerIntSetFunction1( SI4432_RXON|SI4432_XTON);
                                                      ENABLE_MAC_TIMER_INTERRUPT();
                                              }
                                      }
                                      else
                                      {//the channel was busy during the 0.5ms start period
                                         if(BusyLBT == 0)
                               {// LBT passed, channel should be clear in the fix 1ms period
                              // multiple by fixed plus random number
C51 COMPILER V7.20   EZMACPRO_TIMERINT                                                     04/10/2014 16:48:40 PAGE 12  

                              timeout = LBT_FIXED_TIME_5000US + TimeoutLBTI * (U32)(timerIntRandom());
                              // start timer with timeout
                              timerIntTimeout(timeout);
                                                      //go to the next state
                                       EZMacProReg.name.MSR = RX_STATE_BIT | RX_STATE_FORWARDING_LBT_RANDOM_LISTEN;
                                 ENABLE_MAC_TIMER_INTERRUPT();
                               }
                                              else
                                              {//the channel was busy in the fix 1ms period
                                                      if (ChannelOccupiedCounter < 9)
                                                      {
                                                              BusyLBT = 0;
                                      ChannelOccupiedCounter++;
                                                              // start timer with fix 1ms timeout
                              timerIntTimeout(LBT_FIXED_TIME_1000US);
                                                              //go to the next state
                                      EZMacProReg.name.MSR = RX_STATE_BIT | RX_STATE_FORWARDING_LBT_LISTEN;
                                      // disable the receiver
                                                      timerIntSetFunction1(SI4432_XTON);
                                                      // enable the receiver again
                                                      timerIntSetFunction1( SI4432_RXON|SI4432_XTON);
                                                              ENABLE_MAC_TIMER_INTERRUPT();
                                                      }
                                                      else
                                                      {//the channel was busy during the 10*1ms
                                                              BusyLBT = 0;
                                                              EZMacProLBT_Retrys++;
                                                              if(EZMacProLBT_Retrys < MAX_LBT_RETRIES)
                                              {//the channel was busy and the retries didn't reach the maximum value
                                              // disable the reciever
                                              timerIntSetFunction1(SI4432_XTON);
                                              // start timer with fix ETSI timeout
                                              timerIntTimeout(TIMEOUT_LBTI_ETSI);
                                                                      //go to the next state
                                              EZMacProReg.name.MSR = RX_STATE_BIT | RX_STATE_FORWARDING_LBT_START_LISTEN;
                                              ENABLE_MAC_TIMER_INTERRUPT();
                                              // enable the receiver again
                                              timerIntSetFunction1( SI4432_RXON|SI4432_XTON);
                                              }
                                              else
                                              {//the channel was busy and the retries reach the maximum value
                                                      //disable the receiver
                                              timerIntSetFunction1(SI4432_XTON);
                                                                      //go to the next state
                                              EZMacProReg.name.MSR = RX_STATE_BIT | RX_ERROR_FORWARDING_WAIT_FOR_TX;
              #ifdef  FOUR_CHANNEL_IS_USED
                                                                      //increment error counter
                                              timerIntIncrementError(EZMAC_PRO_ERROR_CHANNEL_BUSY);
              #endif//FOUR_CHANNEL_IS_USED
                                                                      //call the LBT error callback function
                                                                      EZMacPRO_LBTTimeout();
                                              }
                                                      }
                                              }
              
                                      }
                                      break;
              
                              case RX_STATE_FORWARDING_LBT_RANDOM_LISTEN:
                                              if(BusyLBT == 0)
                                              {// the channel was free during the 5ms + random period
                                                      //disable the receiver
C51 COMPILER V7.20   EZMACPRO_TIMERINT                                                     04/10/2014 16:48:40 PAGE 13  

                                  timerIntSetFunction1(SI4432_XTON);
                                                      // clear enable 2 interrupt
                                  timerIntSetEnable2(0x00);
                                  // enable ENPKSENT bit
                                  timerIntSpiWriteReg(SI4432_INTERRUPT_ENABLE_1, SI4432_ENPKSENT);
                                  // enable TX
                                  timerIntSetFunction1( SI4432_TXON|SI4432_XTON);
                                  // start timer with fix transmit packet timeout
                                  timerIntTimeout(TimeoutTX_Packet);
                                                      //go to the next state
                                  EZMacProReg.name.MSR = RX_STATE_BIT | RX_STATE_FORWARDING_WAIT_FOR_TX;
                                  ENABLE_MAC_TIMER_INTERRUPT();
                                              }
                                              else
                                              {//the channel was busy during the 5ms + random period
                                                      BusyLBT = 0;
                                                      EZMacProLBT_Retrys++;
                                                      if(EZMacProLBT_Retrys < MAX_LBT_RETRIES)
                                      {//the channel was busy and the retries didn't reach the maximum value
                                      // disable the reciever
                                      timerIntSetFunction1(SI4432_XTON);
                                      // start timer with fix ETSI timeout
                                      timerIntTimeout(TIMEOUT_LBTI_ETSI);
                                                              // go to the next state
                                      EZMacProReg.name.MSR = RX_STATE_BIT | RX_STATE_FORWARDING_LBT_START_LISTEN;
                                      ENABLE_MAC_TIMER_INTERRUPT();
                                      // enable the receiver again
                                      timerIntSetFunction1( SI4432_RXON|SI4432_XTON);
                                      }
                                      else
                                      {//the channel was busy and the retries reach the maximum value
                                              //disable the receiver
                                      timerIntSetFunction1(SI4432_XTON);
                                                              //go to the next state
                                      EZMacProReg.name.MSR = RX_STATE_BIT | RX_ERROR_FORWARDING_WAIT_FOR_TX;
              #ifdef FOUR_CHANNEL_IS_USED
                                                              //increment the error counter
                                      timerIntIncrementError(EZMAC_PRO_ERROR_CHANNEL_BUSY);
              #endif//FOUR_CHANNEL_IS_USED
                                              //cll the LBT error callback function
                                                              EZMacPRO_LBTTimeout();
                                      }
              
                                              }
              
                                      break;
              
              #endif   // TRANSCEIVER_OPERATION
                    case RX_STATE_FORWARDING_WAIT_FOR_TX:
                       // TX timeout - HW error or bad timeout calculation
                       //if there is a TX error then switch back the internal antenna diversity algorthm
              #ifdef ANTENNA_DIVERSITY_ENABLED
              #ifndef B1_ONLY
                                      //if revision V2 or A0 chip is used
                                      if ((EZMacProReg.name.DTR == 0x00) || (EZMacProReg.name.DTR == 0x01))
                                      {
              
                                              //switch ON the internal algorithm
                                              temp8 = timerIntSpiReadReg(SI4432_OPERATING_AND_FUNCTION_CONTROL_2);
                                              timerIntSpiWriteReg (SI4432_OPERATING_AND_FUNCTION_CONTROL_2, temp8 | 0x80);
                                              //the gpios control the rf chip automatically
                                              timerIntSpiWriteReg(SI4432_GPIO1_CONFIGURATION, 0x17);
C51 COMPILER V7.20   EZMACPRO_TIMERINT                                                     04/10/2014 16:48:40 PAGE 14  

                                              timerIntSpiWriteReg(SI4432_GPIO2_CONFIGURATION, 0x18);
                                      }
              #endif//B1_ONLY
              #endif//ANTENNA_DIVERSITY_ENABLED
                                      EZMacProReg.name.MSR = RX_STATE_BIT | RX_ERROR_STATE;
                               //Call the Error state entered callback.
                               EZMacPRO_StateErrorEntered();
                       break;
              #endif   // PACKET_FORWARDING_SUPPORTED
 806   2      
 807   2            case RX_ERROR_STATE:
 808   2               DISABLE_MAC_INTERRUPTS();        // clear EX0 & ET0
 809   2               // disable all Si443x interrupt sources
 810   2               timerIntSpiWriteReg(SI4432_INTERRUPT_ENABLE_1, 0x00);
 811   2               timerIntSetEnable2(0x00);
 812   2                // clear interrupts
 813   2               timerIntSpiReadReg(SI4432_INTERRUPT_STATUS_1);
 814   2               timerIntSpiReadReg(SI4432_INTERRUPT_STATUS_2);
 815   2               STOP_MAC_TIMER();                // stop Timer
 816   2               CLEAR_MAC_TIMER_INTERRUPT();     // clear flag
 817   2               CLEAR_MAC_EXT_INTERRUPT();
 818   2      #ifndef B1_ONLY
                                      if(EZMacProReg.name.DTR == 0)//if rev V2 chip is used
                               // this register setting is need for good current consumption in Idle mode (only rev V2)
                            timerIntSpiWriteReg (SI4432_CRYSTAL_OSCILLATOR_CONTROL_TEST, SI4432_BUFOVR);
              #endif//B1_ONLY
 823   2               break;
 824   2            default:
 825   2               break;
 826   2         }  // end switch
 827   1      }
 828          #endif   // TRANSMITTER_ONLY_OPERATION not defined
 829          
 830          
 831          //-----------------------------------------------------------------------------------------------
 832          // Function Name
 833          //    timerIntRandom()
 834          //
 835          // Return Value : U8 4-bit random number
 836          // Parameters   : None
 837          //
 838          // Notes:
 839          //
 840          // This function provides a pseudo random number.
 841          // It uses 8-bit multiply and shift to generate the next random number.
 842          //
 843          // The constants used are based on the largest possible primes that will
 844          // satisfy the linear congruent criteria.
 845          //
 846          // The pseudo random sequence will repeat every 256 times.
 847          // The sequence always starts at the same point. If the application
 848          // requires a different sequence each time on reset, a truly random
 849          // seed may be required.
 850          //
 851          // This function is only included if LISTEN_BEFORE_TALK_SUPPORTED is defined.
 852          //
 853          //-----------------------------------------------------------------------------------------------
 854          #ifdef TRANSCEIVER_OPERATION
 855          U8 timerIntRandom (void)
 856          {
 857   1              U8 temp8;
 858   1                                                                             // 61 is largest prime less than 256/4
C51 COMPILER V7.20   EZMACPRO_TIMERINT                                                     04/10/2014 16:48:40 PAGE 15  

 859   1         EZMacProRandomNumber *= 245;        // 4 * 61 + 1 = 245
 860   1         EZMacProRandomNumber += 251;        // 251 is the largest prime < 256
 861   1      
 862   1              temp8 = EZMacProRandomNumber>>4;
 863   1              if (temp8 == 0)
 864   1                      return 1;
 865   1              else
 866   1                      return temp8;
 867   1      }
 868          #endif //TRANSCEIVER_OPERATION
 869          
 870          
 871          //------------------------------------------------------------------------------------------------
 872          // Function Name
 873          //    timerIntDisableInterrupts()
 874          //
 875          // Return Value : None
 876          // Parameters   : None
 877          //
 878          // This function is used to disable all interrupts at the completion of a state. Using it saves
 879          // a few bytes of code.
 880          //-----------------------------------------------------------------------------------------------
 881          void timerIntDisableInterrupts (void)
 882          {
 883   1         // disable timer since no subsequent timeout is used
 884   1         DISABLE_MAC_TIMER_INTERRUPT();
 885   1         // clear Interrupt Enable 1 register
 886   1         timerIntSpiWriteReg(SI4432_INTERRUPT_ENABLE_1, 0x00);
 887   1         // clear Interrupt Enable 2 register
 888   1         timerIntSetEnable2 (0x00);
 889   1      }
 890          
 891          
 892          //------------------------------------------------------------------------------------------------
 893          // Function Name
 894          //    timerIntNextRX_Channel()
 895          //
 896          // Return Value : None
 897          // Parameters   : None
 898          //
 899          // Notes:
 900          //
 901          // This function will advance to the next channel. The channel is incremented and then checked
 902          // against the frequency mask in the MAC RCR register. Setting all mask bits is not permitted.
 903          //
 904          // This function is not included for the Transmitter only configuration.
 905          //
 906          //-----------------------------------------------------------------------------------------------
 907          #ifndef TRANSMITTER_ONLY_OPERATION
 908          #ifndef MORE_CHANNEL_IS_USED
 909          void timerIntNextRX_Channel (void)
 910          {
 911   1         U8  mask;
 912   1         U8  n;
 913   1      
 914   1         n = EZMacProCurrentChannel;
 915   1      
 916   1         //initialize mask
 917   1         mask = 0x08;
 918   1         mask <<= n;
 919   1      
 920   1         do
C51 COMPILER V7.20   EZMACPRO_TIMERINT                                                     04/10/2014 16:48:40 PAGE 16  

 921   1         {
 922   2            n++;                             // increment n
 923   2            n &= 0x03;                       // wrap modulo 4
 924   2            mask <<=1 ;                      // shift mask left
 925   2            if(mask == 0x80) mask = 0x08;    // wrap mask to bits 3-6
 926   2      
 927   2            // continue until unmasked bit is found
 928   2         } while ((EZMacProReg.name.RCR & mask) == mask);
 929   1      
 930   1         //switch off the receiver
 931   1         timerIntSetFunction1(SI4432_XTON);
 932   1         timerIntSpiWriteReg (SI4432_FREQUENCY_HOPPING_CHANNEL_SELECT,EZMacProReg.array[FR0+n]);
 933   1         //switch on the receiver
 934   1         timerIntSetFunction1(SI4432_XTON|SI4432_RXON);
 935   1      
 936   1         EZMacProCurrentChannel = n;
 937   1      }
 938          #endif//MORE_CHANNEL_IS_USED
 939          #endif // TRANSMITTER_ONLY_OPERATION not defined
 940          
 941          
 942          //------------------------------------------------------------------------------------------------
 943          // Function Name
 944          //    timerIntGotoNextStateUsingSECR()
 945          //
 946          // Return Value : None
 947          // Parameters   : U8 tx - use SATX bits if non-zero
 948          //
 949          // Notes:
 950          //
 951          // This function is used to put the radio into a programmable state depending on the contents
 952          // of the MAC SECR register. After transmit the SATX bits are used. After RX the SARX bits are
 953          // used.
 954          //
 955          // A U8 (unsigned char) is used for the boolean tx parameter instead of a bit, because a U8 is
 956          // passed in a register.
 957          //
 958          //-----------------------------------------------------------------------------------------------
 959          void timerIntGotoNextStateUsingSECR( U8 tx)
 960          {
 961   1         U8 next;
 962   1      
 963   1      #ifndef TRANSMITTER_ONLY_OPERATION
 964   1          U8 temp8;
 965   1      #endif//TRANSMITTER_ONLY_OPERATION
 966   1      
 967   1         //Disable All interrupts
 968   1         timerIntDisableInterrupts();
 969   1      #ifndef TRANSMITTER_ONLY_OPERATION
 970   1      #ifndef B1_ONLY
                  if(EZMacProReg.name.DTR == 0) //if rev V2 chip is used
                  //set the RX deviation in all case (only rev V2)
                     timerIntSpiWriteReg (SI4432_FREQUENCY_DEVIATION, RX_Freq_dev);
              #endif//B1_ONLY
 975   1      #endif//TRANSMITTER_ONLY_OPERATON
 976   1          //determine the next state
 977   1         if (tx)
 978   1         {    //the next state after transmit
 979   2            next = EZMacProReg.name.SECR >> 6;
 980   2         }
 981   1         else
 982   1         {    //the next state after receive
C51 COMPILER V7.20   EZMACPRO_TIMERINT                                                     04/10/2014 16:48:40 PAGE 17  

 983   2            next =  (EZMacProReg.name.SECR >> 4) & 0x03;
 984   2         }
 985   1      
 986   1         if(next == 0)
 987   1         {  //go to sleep mode
 988   2            // stop XTAL ( TX, RX, PLLON)
 989   2            timerIntSetFunction1 (0x00);
 990   2            EZMacProReg.name.MSR = EZMAC_PRO_SLEEP;
 991   2            //Call the Sleep state entered callback.
 992   2            EZMacPRO_StateSleepEntered();
 993   2         }
 994   1      #ifndef TRANSMITTER_ONLY_OPERATION
 995   1         else if(next == 2)
 996   1         {  //go to RX mode
 997   2      
 998   2            // clear RX FIFO
 999   2            temp8 = timerIntSpiReadReg (SI4432_OPERATING_AND_FUNCTION_CONTROL_2);
1000   2            temp8 |= SI4432_FFCLRRX;
1001   2            timerIntSpiWriteReg (SI4432_OPERATING_AND_FUNCTION_CONTROL_2, temp8);
1002   2            temp8 &= ~SI4432_FFCLRRX;
1003   2            timerIntSpiWriteReg (SI4432_OPERATING_AND_FUNCTION_CONTROL_2, temp8);
1004   2      
1005   2      #ifdef FOUR_CHANNEL_IS_USED
1006   2            // enable preamble detect interrupt
1007   2            timerIntSetEnable2 (SI4432_ENPREAVAL);
1008   2      
1009   2            if((EZMacProReg.name.RCR & 0x04) == 0x04)
1010   2            {
1011   3               //jump to the next channel
1012   3               timerIntNextRX_Channel();
1013   3               // start timer with channel search timeout
1014   3               timerIntTimeout(TimeoutChannelSearch);
1015   3               ENABLE_MAC_TIMER_INTERRUPT();
1016   3            }
1017   2      #endif//FOUR_CHANNEL_IS_USED
1018   2      
1019   2      #ifdef MORE_CHANNEL_IS_USED
                    //enable the preamble detect interrupt
                    timerIntSetEnable2(SI4432_ENPREAVAL);
                      //select the nex channel
                      SelectedChannel = 0;
                      timerIntSpiWriteReg (SI4432_FREQUENCY_HOPPING_CHANNEL_SELECT,EZMacProReg.array[FR0+SelectedChannel
             -]);
                      // start timer with channel search timeout
                      timerIntTimeout(TimeoutChannelSearch);
                    ENABLE_MAC_TIMER_INTERRUPT();
              #endif//MORE_CHANNEL_IS_USED
1029   2            //start receiver
1030   2            timerIntSetFunction1 (SI4432_RXON|SI4432_XTON);
1031   2              //go to the next state
1032   2            EZMacProReg.name.MSR = RX_STATE_BIT | RX_STATE_FREQUENCY_SEARCH;
1033   2            ENABLE_MAC_EXT_INTERRUPT();
1034   2         }
1035   1      #endif // TRANSMITTER_ONLY_OPERATION
1036   1         else //  default
1037   1         {
1038   2            // go to Idle mode
1039   2            // disable RX & TX
1040   2            timerIntSetFunction1 (SI4432_XTON);
1041   2      #ifndef B1_ONLY
                      if(EZMacProReg.name.DTR == 0)//if rev V2 chip is used
                        //this register setting is need for good current consumption in Idle mode (only rev V2)
C51 COMPILER V7.20   EZMACPRO_TIMERINT                                                     04/10/2014 16:48:40 PAGE 18  

                     timerIntSpiWriteReg (SI4432_CRYSTAL_OSCILLATOR_CONTROL_TEST, SI4432_BUFOVR);
              #endif//B1_ONLY
1046   2      #ifdef ANTENNA_DIVERSITY_ENABLED
              #ifndef B1_ONLY
                      //if revision V2 or A0 chip is used
                      if ((EZMacProReg.name.DTR == 0x00) || (EZMacProReg.name.DTR == 0x01))
                      {
              
                          //switch BACK the internal algorithm
                          temp8 = timerIntSpiReadReg(SI4432_OPERATING_AND_FUNCTION_CONTROL_2);
                          timerIntSpiWriteReg (SI4432_OPERATING_AND_FUNCTION_CONTROL_2, temp8 | 0x80);
                          //the gpios control the rf chip automatically
                          timerIntSpiWriteReg(SI4432_GPIO1_CONFIGURATION, 0x17);
                          timerIntSpiWriteReg(SI4432_GPIO2_CONFIGURATION, 0x18);
                      }
              #endif//B1_ONLY
              #endif//ANTENNA_DIVERSITY_ENABLED
1061   2      
1062   2            EZMacProReg.name.MSR = EZMAC_PRO_IDLE;
1063   2            //Call the Idle state entered callback function.
1064   2            EZMacPRO_StateIdleEntered();
1065   2         }
1066   1      }
1067          
1068          
1069          //------------------------------------------------------------------------------------------------
1070          // Function Name
1071          //    timerIntIncrementError()
1072          //
1073          // Return Value : None
1074          // Parameters   : U8 mask - SECR error mask
1075          //
1076          // Notes:
1077          //
1078          // This function will increment the appropriate error counter register if the error type is
1079          // enabled in the MAC SECR register. The error codes for the SECR register are defined in the
1080          // EZMacPro.h header file. First the error code is compared to the error mask in the SECR
1081          // register. The counting is enabled for the particular type of error, the error count is
1082          // incremented. The error count corresponding to the current frequency is incremented.
1083          //
1084          // This function is not included for the Transmitter only configuration.
1085          //
1086          //------------------------------------------------------------------------------------------------
1087          #ifdef FOUR_CHANNEL_IS_USED
1088          #ifndef TRANSMITTER_ONLY_OPERATION
1089          void timerIntIncrementError (U8 mask)
1090          {
1091   1         // mask is SECR error bit mask
1092   1         mask &= 0x0F;                          // ignore upper nibble
1093   1      
1094   1      
1095   1         if((EZMacProReg.name.SECR & mask) == mask )
1096   1         {
1097   2            if(EZMacProReg.array[EC0+EZMacProCurrentChannel] < 255)
1098   2               EZMacProReg.array[EC0+EZMacProCurrentChannel]++;
1099   2         }
1100   1      }
1101          #endif // TRANSMITTER_ONLY_OPERATION not defined
1102          #endif //FOUR_CHANNEL_IS_USED
1103          
1104          //------------------------------------------------------------------------------------------------
1105          // Function Name
C51 COMPILER V7.20   EZMACPRO_TIMERINT                                                     04/10/2014 16:48:40 PAGE 19  

1106          //    timerIntSetEnable2()
1107          //
1108          // Return Value : None
1109          // Parameters   : U8 value
1110          //
1111          // Notes:
1112          //
1113          // This function is used instead of timerIntSpiWriteReg() when writing to the
1114          // SI4432_INTERRUPT_ENABLE_2 register. This function adds support for the low frequency timer
1115          // and low battery detector, if the build options are defined. If not, the register is written
1116          // directly.
1117          //
1118          // This function is not included for the Transmitter only configuration.
1119          //
1120          //------------------------------------------------------------------------------------------------
1121          void timerIntSetEnable2(U8 value)
1122          {
1123   1         if((EZMacProReg.name.LFTMR2 & 0x80)==0x80)
1124   1         {
1125   2            value |= SI4432_ENWUT;
1126   2         }
1127   1      
1128   1         if((EZMacProReg.name.LBDR & 0x80)==0x80)
1129   1            value |= SI4432_ENLBDI;
1130   1      
1131   1         timerIntSpiWriteReg(SI4432_INTERRUPT_ENABLE_2, value);
1132   1      }
1133          //------------------------------------------------------------------------------------------------
1134          // Function Name
1135          //    timerIntSetFunction1()
1136          //
1137          // Return Value : None
1138          // Parameters   : U8 value
1139          //
1140          // This function is used instead of timerIntSpiWriteReg() when writing to the
1141          // SI4432_OPERATING_AND_FUNCTION_CONTROL_1 register. This function adds support for the
1142          // low frequency timer and low battery detector, if the build options are defined. If not,
1143          // the register is written directly.
1144          //
1145          // This function is not included for the Transmitter only configuration.
1146          //
1147          //------------------------------------------------------------------------------------------------
1148          #ifndef TRANSMITTER_ONLY_OPERATION
1149          void timerIntSetFunction1(U8 value)
1150          {
1151   1         if((EZMacProReg.name.LFTMR2 & 0x80)==0x80)
1152   1         {
1153   2            value |= SI4432_ENWT;
1154   2            ENABLE_MAC_EXT_INTERRUPT();
1155   2         }
1156   1         if((EZMacProReg.name.LFTMR2 & 0x40)==0x00)
1157   1            value |= SI4432_X32KSEL;
1158   1      
1159   1         if((EZMacProReg.name.LBDR & 0x80)==0x80)
1160   1            value |= SI4432_ENLBD;
1161   1      
1162   1         timerIntSpiWriteReg(SI4432_OPERATING_AND_FUNCTION_CONTROL_1, value);
1163   1      }
1164          #endif//TRANSMITTER_ONLY_OPERATION
1165          
1166          

C51 COMPILER V7.20   EZMACPRO_TIMERINT                                                     04/10/2014 16:48:40 PAGE 20  


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1046    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      2       9
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
