C51 COMPILER V7.20   EZMACPRO                                                              04/10/2014 16:48:40 PAGE 1   


C51 COMPILER V7.20, COMPILATION OF MODULE EZMACPRO
OBJECT MODULE PLACED IN EZMacPro.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\c51.exe EZMacPro.c DB OE BR DF(SI1000MB_SI1000,FREQUENCY_BAND_434,TRANSCEIVER_OPERA
                    -TION,FOUR_CHANNEL_IS_USED,EXTENDED_PACKET_FORMAT,TRACE_ENABLED) INCDIR(..\..\bsp;..\..\stack;c:\SiLabs\MCU_3\Inc)

line level    source

   1          /*!\file EZMacPro.c
   2           * \brief EZMacPRO stack functions.
   3           *
   4           * \n EZMacPRO version: 3.0.1r
   5           *
   6           * \n This software must be used in accordance with the End User License
   7           * \n Agreement.
   8           *
   9           * \b COPYRIGHT
  10           * \n Copyright 2012 Silicon Laboratories, Inc.
  11           * \n http://www.silabs.com
  12           */
  13          
  14          
  15                          /* ======================================= *
  16                           *              I N C L U D E              *
  17                           * ======================================= */
  18          
  19          #include "stack.h"
  20          
  21          
  22                          /* ======================================= *
  23                           *     G L O B A L   V A R I A B L E S     *
  24                           * ======================================= */
  25          
  26          SEGMENT_VARIABLE(EZMacProReg, EZMacProUnion, REGISTER_MSPACE);
  27          SEGMENT_VARIABLE(EZMacProCurrentChannel, U8, EZMAC_PRO_GLOBAL_MSPACE);
  28          
  29          #ifdef EXTENDED_PACKET_FORMAT
  30          SEGMENT_VARIABLE(TimeoutACK, U32, EZMAC_PRO_GLOBAL_MSPACE);
  31          SEGMENT_VARIABLE(EZMacProSequenceNumber, U8, EZMAC_PRO_GLOBAL_MSPACE);
  32          SEGMENT_VARIABLE(PreamRegValue, U8, EZMAC_PRO_GLOBAL_MSPACE);
  33          #endif//EXTENDED_PACKET_FORMAT
  34          
  35          #ifndef TRANSMITTER_ONLY_OPERATION
  36          BIT fHeaderErrorOccurred;
  37          SEGMENT_VARIABLE(RxBuffer[RECEIVED_BUFFER_SIZE], U8 , BUFFER_MSPACE);
  38          #ifdef EXTENDED_PACKET_FORMAT
  39          SEGMENT_VARIABLE(AckBufSize, U8 , EZMAC_PRO_GLOBAL_MSPACE);
  40          SEGMENT_VARIABLE(AckBuffer[ACK_BUFFER_SIZE], U8 , BUFFER_MSPACE);
  41          #endif//EXTENDED_PACKET_FORMAT
  42          SEGMENT_VARIABLE(EZMacProReceiveStatus, U8, EZMAC_PRO_GLOBAL_MSPACE);
  43          SEGMENT_VARIABLE(EZMacProRSSIvalue, U8, EZMAC_PRO_GLOBAL_MSPACE);
  44          SEGMENT_VARIABLE(TimeoutSyncWord, U32, EZMAC_PRO_GLOBAL_MSPACE);
  45          SEGMENT_VARIABLE(TimeoutRX_Packet, U32, EZMAC_PRO_GLOBAL_MSPACE);
  46          #ifndef B1_ONLY
              SEGMENT_VARIABLE(RX_Freq_dev, U8, EZMAC_PRO_GLOBAL_MSPACE);
              #endif//B1_ONLY
  49          SEGMENT_VARIABLE(TimeoutChannelSearch, U32, EZMAC_PRO_GLOBAL_MSPACE);
  50          #endif//TRANSMITTER_ONLY_OPERATION
  51          
  52          #ifndef RECEIVER_ONLY_OPERATION
  53          SEGMENT_VARIABLE(TimeoutTX_Packet, U32, EZMAC_PRO_GLOBAL_MSPACE);
  54          #ifndef B1_ONLY
C51 COMPILER V7.20   EZMACPRO                                                              04/10/2014 16:48:40 PAGE 2   

              SEGMENT_VARIABLE(TX_Freq_dev, U8, EZMAC_PRO_GLOBAL_MSPACE);
              #endif//B1_ONLY
  57          #endif//RECEIVER_ONLY_OPERATION
  58          
  59          #ifdef TRANSCEIVER_OPERATION
  60          SEGMENT_VARIABLE(TimeoutLBTI, U32, EZMAC_PRO_GLOBAL_MSPACE);
  61          SEGMENT_VARIABLE(BusyLBT, U8, EZMAC_PRO_GLOBAL_MSPACE);
  62          SEGMENT_VARIABLE(EZMacProRandomNumber, U8, EZMAC_PRO_GLOBAL_MSPACE);
  63          SEGMENT_VARIABLE(EZMacProLBT_Retrys, U8, EZMAC_PRO_GLOBAL_MSPACE);
  64          #endif//TRANSCEIVER_OPERATION
  65          
  66          #ifdef PACKET_FORWARDING_SUPPORTED
              SEGMENT_VARIABLE(ForwardedPacketTable[FORWARDED_PACKET_TABLE_SIZE], ForwardedPacketTableEntry, FORWARDED_P
             -ACKET_TABLE_MSPACE);
              #endif//PACKET_FORWARDING_SUPPOERTED
  69          
  70          #ifdef ANTENNA_DIVERSITY_ENABLED
              SEGMENT_VARIABLE(Selected_Antenna, U8, EZMAC_PRO_GLOBAL_MSPACE);
              #endif//ANTENNA_DIVERSITY_ENABLED
  73          
  74          #ifdef MORE_CHANNEL_IS_USED
              SEGMENT_VARIABLE(SelectedChannel, U8, EZMAC_PRO_GLOBAL_MSPACE);
              SEGMENT_VARIABLE(maxChannelNumber, U8, EZMAC_PRO_GLOBAL_MSPACE);
              #endif //MORE_CHANNEL_IS_USED
  78          
  79          
  80                          /* ======================================= *
  81                           *     P U B L I C  F U N C T I O N S      *
  82                           * ======================================= */
  83          
  84          //------------------------------------------------------------------------------------------------
  85          // Function Name:       EZMacPRO_Init()
  86          //                                              Initializes the EZRadioPRO device. The function has to be called in the power-on routine.
  87          // Return Values : MAC_OK: if the MAC recognized the used chip
  88          //                                              CHIPTYPE_ERROR: if the MAC didn't recognize the used chip
  89          //------------------------------------------------------------------------------------------------
  90          MacParams EZMacPRO_Init(void)
  91          {
  92   1         U8 temp8;
  93   1         unsigned short timeout;
  94   1         DISABLE_MAC_INTERRUPTS();                     // disable MAC interrupts
  95   1         //Set the init value of the MAC registers
  96   1         for(temp8=0;temp8<EZ_LASTREG;temp8++)
  97   1            EZMacProReg.array[temp8] = 0x00;
  98   1              EZMacProReg.name.MCR    = 0x1C;
  99   1         EZMacProReg.name.SECR   = 0x50;
 100   1         EZMacProReg.name.TCR    = 0x38;
 101   1         EZMacProReg.name.RCR    = 0x04;
 102   1      #ifdef FOUR_CHANNEL_IS_USED
 103   1         EZMacProReg.name.FR1    = 1;
 104   1         EZMacProReg.name.FR2    = 2;
 105   1         EZMacProReg.name.FR3    = 3;
 106   1      #endif//FOUR_CHANNEL_IS_USED
 107   1      #ifdef MORE_CHANNEL_IS_USED
                      for(temp8=0;temp8<50;temp8++)
                              EZMacProReg.array[4+temp8] = FrequencyTable[temp8];
              #endif//MORE_CHANNEL_IS_USED
 111   1         EZMacProReg.name.PFCR   = 0x02;
 112   1         EZMacProReg.name.MPL    = 0x40;
 113   1         EZMacProReg.name.MSR    = 0x00;
 114   1         EZMacProReg.name.SCID   = 0xCD;
 115   1         EZMacProReg.name.SFID   = 0x01;
C51 COMPILER V7.20   EZMACPRO                                                              04/10/2014 16:48:40 PAGE 3   

 116   1         EZMacProReg.name.PLEN   = 0x01;
 117   1      #ifdef TRANSCEIVER_OPERATION
 118   1         EZMacProReg.name.LBTLR  = 0x78; // -60 dBm
 119   1         EZMacProReg.name.LBTIR  = 0x8A;
 120   1      #endif//TRANSCEIVER_OPERATION
 121   1         EZMacProReg.name.LBDR   = 0x14;
 122   1         EZMacProReg.name.LFTMR2 = 0x40;
 123   1      
 124   1         // read Si443x interrupts to clear
 125   1         macSpiReadReg(SI4432_INTERRUPT_STATUS_1);
 126   1         macSpiReadReg(SI4432_INTERRUPT_STATUS_2);
 127   1         CLEAR_MAC_EXT_INTERRUPT();          // clear INT0 flag
 128   1      
 129   1              //enable only the chip ready interrupt
 130   1         macSpiWriteReg(SI4432_INTERRUPT_ENABLE_1, 0x00);
 131   1         macSpiWriteReg(SI4432_INTERRUPT_ENABLE_2, SI4432_ENCHIPRDY);
 132   1      
 133   1      
 134   1         //EZMac state Software Reset
 135   1         EZMacProReg.name.MSR = EZMAC_PRO_WAKE_UP;
 136   1         //Call the wake-up state entered callback.
 137   1         EZMacPRO_StateWakeUpEntered();
 138   1         //Send the Software Reset Command to the radio
 139   1         //use direct write since LBD and WUT initially disabled
 140   1         macSpiWriteReg (SI4432_OPERATING_AND_FUNCTION_CONTROL_1, (SI4432_SWRES|SI4432_XTON));
 141   1      
 142   1         // set time out to XTAL start-up time
 143   1         macTimeout (TIMEOUT_XTAL_START);
 144   1      
 145   1         ENABLE_MAC_INTERRUPTS();         // enable INT0  & T0 interrupt
 146   1      
 147   1         //wait until the MAC goes to Idle State
 148   1         //while (EZMacProReg.name.MSR != EZMAC_PRO_IDLE);
 149   1         timeout = 200;
 150   1         while(EZMacProReg.name.MSR != EZMAC_PRO_IDLE){
 151   2               if(1 > timeout){
 152   3                       ENABLE_WATCHDOG();
 153   3               }
 154   2               else{
 155   3                       delay_ms(10);
 156   3                       timeout--;
 157   3               }
 158   2         }
 159   1      
 160   1         // clear Chip ready and POR interrupts
 161   1         macSpiWriteReg(SI4432_INTERRUPT_ENABLE_1, 0x00);
 162   1         macSpiWriteReg(SI4432_INTERRUPT_ENABLE_2, 0x00);
 163   1      
 164   1        /*Si443x configuration*/
 165   1      
 166   1      #ifdef EXTENDED_PACKET_FORMAT
 167   1         if (( EZMacProReg.name.MCR & 0x80 ) == 0x80)//if CID is used
 168   1            //header length 4 byte(CTRL+CID+SID+DID)
 169   1            macSpiWriteReg(SI4432_HEADER_CONTROL_2, SI4432_HDLEN_4BYTE | (SYNC_WORD_LENGTH - 1) << 1);
 170   1         else
 171   1            //header length 3 byte(CTRL+SID+DID)
 172   1            macSpiWriteReg(SI4432_HEADER_CONTROL_2, SI4432_HDLEN_3BYTE | (SYNC_WORD_LENGTH - 1 ) << 1);
 173   1      #else //STANDARD_PACKET_FORMAT
                 if (( EZMacProReg.name.MCR & 0x80 ) == 0x80)//if CID is used
                    //header length 3 byte(CID+SID+DID)
                    macSpiWriteReg(SI4432_HEADER_CONTROL_2, SI4432_HDLEN_3BYTE | (SYNC_WORD_LENGTH - 1) << 1);
                 else
C51 COMPILER V7.20   EZMACPRO                                                              04/10/2014 16:48:40 PAGE 4   

                    //header length 2 byte(SID+DID)
                    macSpiWriteReg(SI4432_HEADER_CONTROL_2, SI4432_HDLEN_2BYTE | (SYNC_WORD_LENGTH - 1) << 1);
              #endif//EXTENDED_PACKET_FORMAT
 181   1         //Clear the Header Control Register
 182   1         macSpiWriteReg(SI4432_HEADER_CONTROL_1, 0x00);
 183   1              //Set the SYNC WORD
 184   1              macSpiWriteReg(SI4432_SYNC_WORD_3, 0x2D);
 185   1              macSpiWriteReg(SI4432_SYNC_WORD_2, 0xD4);
 186   1      
 187   1         //Set the modem, frequency parameters and preamble length according to the init register value
 188   1         SetRfParameters(EZMacProReg.name.MCR);
 189   1      
 190   1         //set GPIO0, GPIO1 and GPIO2 to the init values
 191   1              //the init values are in the EZMacPro_defs.h
 192   1         macSpiWriteReg(SI4432_GPIO0_CONFIGURATION, GPIO0_FUNCTION);
 193   1         macSpiWriteReg(SI4432_GPIO1_CONFIGURATION, GPIO1_FUNCTION);
 194   1         macSpiWriteReg(SI4432_GPIO2_CONFIGURATION, GPIO2_FUNCTION);
 195   1      
 196   1         //enable packet handler & CRC16
 197   1         macSpiWriteReg(SI4432_DATA_ACCESS_CONTROL, SI4432_ENPACTX | SI4432_ENPACRX | SI4432_ENCRC | SI4432_CRC_
             -16);
 198   1      
 199   1         //FIFO mode, GFSK modulation, TX Data Clk is available via the GPIO
 200   1         macSpiWriteReg(SI4432_MODULATION_MODE_CONTROL_2, SI4432_MODTYP_GFSK | SI4432_FIFO_MODE | SI4432_TX_DATA
             -_CLK_GPIO);
 201   1      
 202   1         //reset digital testbus, disable scan test
 203   1         macSpiWriteReg(SI4432_DIGITAL_TEST_BUS, 0x00);
 204   1      
 205   1         //select nothing to the Analog Testbus
 206   1         macSpiWriteReg(SI4432_ANALOG_TEST_BUS, 0x0B);
 207   1      
 208   1      #ifdef PACKET_FORWARDING_SUPPORTED
                 initForwardedPacketTable ();
              #endif
 211   1      #ifndef B1_ONLY
                      //read out the device type register
                      temp8 =         macSpiReadReg (SI4432_DEVICE_VERSION);
                      if (temp8 == 0x02) EZMacProReg.name.DTR = 0x00;                         //revision V2
                      else if (temp8 == 0x04) EZMacProReg.name.DTR = 0x01;            //revision A0
                      else if (temp8 == 0x06) EZMacProReg.name.DTR = 0x02;            //revision B1
                      else
                      {
                              EZMacProReg.name.DTR = 0x02;                                                                    //default: rev B1
                              temp8 = 1;
                      }
              #endif
 223   1      #ifdef B1_ONLY
 224   1              EZMacProReg.name.DTR = 0x02;                                                                    //default: rev B1
 225   1      #endif
 226   1              //set the non-default, special registers accoring to the device type
 227   1              macSpecialRegisterSettings(EZMacProReg.name.DTR);
 228   1      
 229   1      #ifndef B1_ONLY
                      if (EZMacProReg.name.DTR == 0x00)//if rev V2 chip is used
                              //set crystal oscillator control test
                              macSpiWriteReg (SI4432_CRYSTAL_OSCILLATOR_CONTROL_TEST, 0x24);
              #endif//B1_ONLY
 234   1      
 235   1      #ifdef ANTENNA_DIVERSITY_ENABLED
                              Selected_Antenna = 1;
                              //switch ON the internal algorithm
C51 COMPILER V7.20   EZMACPRO                                                              04/10/2014 16:48:40 PAGE 5   

                              temp8 = macSpiReadReg(SI4432_OPERATING_AND_FUNCTION_CONTROL_2);
                      macSpiWriteReg (SI4432_OPERATING_AND_FUNCTION_CONTROL_2, temp8 | 0x80);
              #endif//ANTENNA_DIVERSITY_ENABLED
 241   1      
 242   1         // stop Si443x xtal, clear TX, RX , PLL
 243   1         // use direct write since LBD and WUT initially disabled
 244   1         macSpiWriteReg (SI4432_OPERATING_AND_FUNCTION_CONTROL_1, 0x00);
 245   1      
 246   1              //after EZMAC init the next state is SLEEP
 247   1         EZMacProReg.name.MSR = EZMAC_PRO_SLEEP;
 248   1         //Call the Sleep state entered callback.
 249   1         EZMacPRO_StateSleepEntered();
 250   1      #ifndef B1_ONLY
                      if(temp8 == 0)
                              //if the MAC recognize the chip type
                              return MAC_OK;
                      else
                              //if the MAC doesn't recognize the chip type
                              return CHIPTYPE_ERROR;
              #endif//B1_ONLY
 258   1      #ifdef B1_ONLY
 259   1              return MAC_OK;
 260   1      #endif//B1_ONLY
 261   1      }
 262          //-----------------------------------------------------------------------------------------------
 263          // Function Name :      EZMAcPRO_Sleep()
 264          //                                                      Switch the MAC from IDLE to SLEEP mode. It turns off the crystal oscillator
 265          //                                                      on the radio. This function can be call from only Idle state.
 266          // Return Values :      MAC_OK: the operation was successful.
 267          //                                                      STATE_ERROR: the operation is ignored because the MAC was not in IDLE mode
 268          //-----------------------------------------------------------------------------------------------
 269          MacParams EZMacPRO_Sleep(void)
 270          {
 271   1         if (EZMacProReg.name.MSR == EZMAC_PRO_IDLE)
 272   1         {
 273   2            DISABLE_MAC_INTERRUPTS();         // disable MAC interrupts, just in case
 274   2      
 275   2                      if (EZMacProReg.name.DTR == 0x00) //if rev V2 chip is used
 276   2              //this register setting is needed (only rev V2)
 277   2              macSpiWriteReg (SI4432_CRYSTAL_OSCILLATOR_CONTROL_TEST, 0x24);
 278   2      
 279   2            // disable Si443x interrupt sources
 280   2            macSpiWriteReg(SI4432_INTERRUPT_ENABLE_1, 0x00);
 281   2            /* Keep WUT and LBD enabled if these are enabled in LFTMR2 and LBDR. */
 282   2            macSetEnable2(0x00);
 283   2      
 284   2            // stop Si443x xtal, clear TX, RX , PLL
 285   2            macSetFunction1(0x00);
 286   2                      // next state after this function is SLEEP
 287   2            EZMacProReg.name.MSR = EZMAC_PRO_SLEEP;
 288   2            //Call the Sleep state entered callback.
 289   2            EZMacPRO_StateSleepEntered();
 290   2            /* Enable External0 INT for WUT and LBD to work correctly. */
 291   2            ENABLE_MAC_EXT_INTERRUPT();
 292   2            return MAC_OK;
 293   2         }
 294   1         else
 295   1            return STATE_ERROR;
 296   1      }
 297          //------------------------------------------------------------------------------------------------
 298          // Function Name :      EZMacPRO_Wake_Up
 299          //                                                      Switches the MAC from SLEEP mode into IDLE mode. Turns on the crystal oscillator
C51 COMPILER V7.20   EZMACPRO                                                              04/10/2014 16:48:40 PAGE 6   

 300          //                                                      of the radio, so the current consumption increases.The MAC has to be in SLEEP mode
 301          //                                                      when calling the function.
 302          // Return Values :      MAC_OK: the operation was successful.
 303          //                                                      STATE_ERROR: the operation is ignored because the MAC was not in SLEEP mode.
 304          //------------------------------------------------------------------------------------------------
 305          MacParams EZMacPRO_Wake_Up(void)
 306          {
 307   1              unsigned short timeout;
 308   1         if (EZMacProReg.name.MSR == EZMAC_PRO_SLEEP)
 309   1         {
 310   2            DISABLE_MAC_INTERRUPTS();        // disable MAC interrupts, just in case
 311   2      
 312   2            // disable Si443x interrupt 2 sources except ENLBDI & SI4432_ENWUT
 313   2            macSpiWriteReg(SI4432_INTERRUPT_ENABLE_1, 0x00);
 314   2            // enable chip ready interrupt
 315   2            macSetEnable2(SI4432_ENCHIPRDY);
 316   2      
 317   2            // clear interrupts
 318   2            macSpiReadReg(SI4432_INTERRUPT_STATUS_1);
 319   2            macSpiReadReg(SI4432_INTERRUPT_STATUS_2);
 320   2            CLEAR_MAC_EXT_INTERRUPT();
 321   2      
 322   2            // start Si443x XTAL
 323   2            macSetFunction1(SI4432_XTON);
 324   2                      // start timer with XTAL startup timeout
 325   2            macTimeout (TIMEOUT_XTAL_START);
 326   2                      // next state is WAKE UP state
 327   2            EZMacProReg.name.MSR = EZMAC_PRO_WAKE_UP;
 328   2            //Call the wake-up state entered callback.
 329   2            EZMacPRO_StateWakeUpEntered();
 330   2      
 331   2            ENABLE_MAC_INTERRUPTS();
 332   2            //wait until the MAC goes to Idle State
 333   2            // while (EZMacProReg.name.MSR != EZMAC_PRO_IDLE);
 334   2                timeout = 200;
 335   2                while(EZMacProReg.name.MSR != EZMAC_PRO_IDLE){
 336   3                      if(1 > timeout){
 337   4                              ENABLE_WATCHDOG();
 338   4                      }
 339   3                      else{
 340   4                          delay_ms(10);
 341   4                          timeout--;
 342   4                      }
 343   3                }
 344   2      
 345   2            return MAC_OK;
 346   2         }
 347   1         else
 348   1            return STATE_ERROR;
 349   1      }
 350          //------------------------------------------------------------------------------------------------
 351          // Function Name        :       EZMacPRO_Idle()
 352          //                                                      This is the only function that aborts the ongoing reception and transmission.
 353          //                                                      It could be used to reset the state of the MAC. Calling this function,
 354          //                                                      EZMAC PRO goes into IDLE state.The function cannot be called in SLEEP mode.
 355          //
 356          // Return Values        :       MAC_OK: the MAC is set into IDLE mode, and no transmission or reception was aborted.
 357          //                                                      STATE_ERROR: the MAC is set into IDLE mode, and transmission or reception was aborted
 358          //------------------------------------------------------------------------------------------------
 359          MacParams EZMacPRO_Idle(void)
 360          {
 361   1              //if the MAC in sleep state
C51 COMPILER V7.20   EZMACPRO                                                              04/10/2014 16:48:40 PAGE 7   

 362   1         if (EZMacProReg.name.MSR == EZMAC_PRO_SLEEP)
 363   1         {
 364   2            return STATE_ERROR;
 365   2         }
 366   1      
 367   1         DISABLE_MAC_INTERRUPTS();        // clear EX0 & ET0
 368   1      
 369   1         // disable all Si443x interrupt sources
 370   1         macSpiWriteReg(SI4432_INTERRUPT_ENABLE_1, 0x00);
 371   1         macSetEnable2(0x00);
 372   1      
 373   1         // clear interrupts
 374   1         macSpiReadReg(SI4432_INTERRUPT_STATUS_1);
 375   1         macSpiReadReg(SI4432_INTERRUPT_STATUS_2);
 376   1      
 377   1         STOP_MAC_TIMER();                // stop Timer
 378   1         CLEAR_MAC_TIMER_INTERRUPT();     // clear flag
 379   1         CLEAR_MAC_EXT_INTERRUPT();
 380   1      #ifndef B1_ONLY
                      if (EZMacProReg.name.DTR == 0x00) //if the rev V2 chip is used
                              // this register setting is need for good current consumption in Idle mode (only rev V2)
                      macSpiWriteReg (SI4432_CRYSTAL_OSCILLATOR_CONTROL_TEST, SI4432_BUFOVR);
              #endif//B1_ONLY
 385   1         // shut-down radio except for xtal
 386   1         macSetFunction1(SI4432_XTON);
 387   1         macSpiWriteReg (SI4432_OPERATING_AND_FUNCTION_CONTROL_2, 0x00 );
 388   1      
 389   1         if (EZMacProReg.name.MSR & (TX_STATE_BIT|RX_STATE_BIT))
 390   1         {//if the ongoing reception and transmission aborts
 391   2                      // the next state is IDLE state
 392   2            EZMacProReg.name.MSR = EZMAC_PRO_IDLE;
 393   2            //Call the Idle state entered callback function.
 394   2            EZMacPRO_StateIdleEntered();
 395   2            return STATE_ERROR;
 396   2         }
 397   1         else
 398   1         {
 399   2                      // the next state is IDLE state
 400   2            EZMacProReg.name.MSR = EZMAC_PRO_IDLE;
 401   2            //Call the Idle state entered callback function.
 402   2            EZMacPRO_StateIdleEntered();
 403   2            return MAC_OK;
 404   2         }
 405   1      }
 406          //------------------------------------------------------------------------------------------------
 407          // Function Name:       EZMacPRO_Transmit()
 408          //                                              It starts to transmit a packet.All the parameters have to be set before calling
 409          //                                              this function.  EZMAC PRO has to be in IDLE mode when calling this function.
 410          //
 411          // Return Values: MAC_OK: the transmission started correctly.
 412          //                                              STATE_ERROR: the operation ignored (the transmission has not been started), because the
 413          //                                              EZMAC PRO was not in IDLE mode.
 414          //------------------------------------------------------------------------------------------------
 415          #ifndef RECEIVER_ONLY_OPERATION
 416          MacParams EZMacPRO_Transmit(void)
 417          {
 418   1      
 419   1         U8 temp8;
 420   1              //if the MAC is not in Idle state
 421   1         if (EZMacProReg.name.MSR != EZMAC_PRO_IDLE)
 422   1               return STATE_ERROR;
 423   1      
C51 COMPILER V7.20   EZMACPRO                                                              04/10/2014 16:48:40 PAGE 8   

 424   1         DISABLE_MAC_INTERRUPTS();        // clear EX0 & ET0
 425   1      #ifndef B1_ONLY
                      if(EZMacProReg.name.DTR == 0) //if the rev V2 chip is used
                      {
                      //this register setting is needed (only rev V2)
                      macSpiWriteReg (SI4432_CRYSTAL_OSCILLATOR_CONTROL_TEST, 0x24);
                         //set the TX deviation (only rev V2)
                         macSpiWriteReg (SI4432_FREQUENCY_DEVIATION, TX_Freq_dev);
                      }
              #endif//B1_ONLY
 434   1      #ifdef ANTENNA_DIVERSITY_ENABLED
              #ifndef B1_ONLY
                      //if revision V2 or A0 chip is used
                      if ((EZMacProReg.name.DTR == 0x00) || (EZMacProReg.name.DTR == 0x01))
                      {
              
                              //switch OFF the internal algorithm
                              temp8 = macSpiReadReg(SI4432_OPERATING_AND_FUNCTION_CONTROL_2);
                         macSpiWriteReg (SI4432_OPERATING_AND_FUNCTION_CONTROL_2, temp8 & 0x7F);
              
                              //select the TX antenna
                      if ( Selected_Antenna == 1 )
                      {
                         //select antenna 1
                         macSpiWriteReg(SI4432_GPIO1_CONFIGURATION, 0x1D);
                         macSpiWriteReg(SI4432_GPIO2_CONFIGURATION, 0x1F);
                      }
                      else
                      {
                         //select antenna 2
                              macSpiWriteReg(SI4432_GPIO1_CONFIGURATION, 0x1F);
                              macSpiWriteReg(SI4432_GPIO2_CONFIGURATION, 0x1D);
                      }
                      }
              #endif//B1_ONLY
              #endif//ANTENNA_DIVERSITY_ENABLED
 460   1      
 461   1         //select the TX frequency
 462   1      #ifdef FOUR_CHANNEL_IS_USED
 463   1         //if AFCH bit is cleared in the Transmit Control Register
 464   1         if( (EZMacProReg.name.TCR & 0x04) == 0x04)
 465   1         {
 466   2            //select the first frequency channel according to Frequency Register 0
 467   2            macSpiWriteReg (SI4432_FREQUENCY_HOPPING_CHANNEL_SELECT,EZMacProReg.name.FR0);
 468   2            EZMacProCurrentChannel = 0;
 469   2         }
 470   1              else
 471   1              {
 472   2            //select the proper frequency register according to FSR register
 473   2            temp8 = EZMacProReg.name.FSR;
 474   2                 //in case of four channel is only for channel is allowed
 475   2                      if(temp8>3) temp8 = 0;
 476   2            macSpiWriteReg (SI4432_FREQUENCY_HOPPING_CHANNEL_SELECT,EZMacProReg.array[FR0+temp8]);
 477   2            EZMacProCurrentChannel = temp8;
 478   2              }
 479   1      #endif//FOUR_CHANNEL_IS_USED
 480   1      #ifdef MORE_CHANNEL_IS_USED
                    //select the proper frequency register according to FSR register
                    temp8 = EZMacProReg.name.FSR;
                    macSpiWriteReg (SI4432_FREQUENCY_HOPPING_CHANNEL_SELECT,EZMacProReg.array[FR0+temp8]);
                    EZMacProCurrentChannel = temp8;
              #endif//MORE_CHANNEL_IS_USED
C51 COMPILER V7.20   EZMACPRO                                                              04/10/2014 16:48:40 PAGE 9   

 486   1      
 487   1      #ifdef EXTENDED_PACKET_FORMAT
 488   1         //Assemble the CTRL byte
 489   1              //set radius field
 490   1         temp8 = (EZMacProReg.name.MCR >>3) & 0x03;
 491   1         if ( (EZMacProReg.name.TCR & 0x80) == 0x80 )
 492   1            temp8 |= 0x04;           //ACK request
 493   1              //set the Sequence number
 494   1         if ( EZMacProSequenceNumber < 15)
 495   1            EZMacProSequenceNumber++;
 496   1         else
 497   1            EZMacProSequenceNumber = 0;
 498   1      
 499   1         temp8 |= (EZMacProSequenceNumber<<4);
 500   1      
 501   1         // set the transmit headers
 502   1              if (( EZMacProReg.name.MCR & 0x80 ) == 0x80)//if CID is used
 503   1              {
 504   2                      macSpiWriteReg(SI4432_TRANSMIT_HEADER_3, temp8); // CTRL
 505   2            macSpiWriteReg(SI4432_TRANSMIT_HEADER_2, EZMacProReg.name.SCID);
 506   2            macSpiWriteReg(SI4432_TRANSMIT_HEADER_1, EZMacProReg.name.SFID);
 507   2            macSpiWriteReg(SI4432_TRANSMIT_HEADER_0, EZMacProReg.name.DID);
 508   2              }
 509   1              else
 510   1              {//if CID is not used
 511   2            macSpiWriteReg(SI4432_TRANSMIT_HEADER_3, temp8); // CTRL
 512   2            macSpiWriteReg(SI4432_TRANSMIT_HEADER_2, EZMacProReg.name.SFID);
 513   2            macSpiWriteReg(SI4432_TRANSMIT_HEADER_1, EZMacProReg.name.DID);
 514   2              }
 515   1      #endif   // EXTENDED_PACKET_FORMAT
 516   1      
 517   1      #ifdef TRANSCEIVER_OPERATION
 518   1         if(((EZMacProReg.name.TCR & 0x08)==0x08) && ((EZMacProReg.name.TCR & 0x04)==0x00))// LBT enabled and th
             -e AFCH is not enabled
 519   1         {
 520   2            //Set Listen Before Talk Limit to RSSI threshold register
 521   2            macSpiWriteReg(SI4432_RSSI_THRESHOLD, EZMacProReg.name.LBTLR);
 522   2      
 523   2            // clear interrupts
 524   2            macSpiReadReg(SI4432_INTERRUPT_STATUS_1);
 525   2            macSpiReadReg(SI4432_INTERRUPT_STATUS_2);
 526   2      
 527   2      
 528   2            // disable all Si443x interrupt enable 1 sources
 529   2            macSpiWriteReg(SI4432_INTERRUPT_ENABLE_1, 0x00);
 530   2            // enable RSSI interrupt
 531   2            macSetEnable2(SI4432_ENRSSI);
 532   2                      //clear the LBT variable
 533   2            EZMacProLBT_Retrys = 0;
 534   2            BusyLBT = 0;
 535   2                      // go to next state
 536   2            EZMacProReg.name.MSR = TX_STATE_BIT | TX_STATE_LBT_START_LISTEN;
 537   2            //Call the TX state entered callback.
 538   2            EZMacPRO_StateTxEntered();
 539   2      
 540   2            //first timeout is fix 0.5ms
 541   2                      // start timer with LBT ETSI fix timeout
 542   2            macTimeout(TIMEOUT_LBTI_ETSI);
 543   2            // enable RX
 544   2            macSetFunction1 (SI4432_RXON|SI4432_XTON);
 545   2            ENABLE_MAC_INTERRUPTS();
 546   2            return MAC_OK;
C51 COMPILER V7.20   EZMACPRO                                                              04/10/2014 16:48:40 PAGE 10  

 547   2         }
 548   1      #endif //TRANSCEIVER_OPERATION
 549   1         // go straight to transmit without LBT
 550   1         // enable ENPKSENT bit
 551   1         macSpiWriteReg (SI4432_INTERRUPT_ENABLE_1, SI4432_ENPKSENT);
 552   1         // disable enable 2 using function
 553   1         macSetEnable2 (0x00);
 554   1         // clear interrupt status
 555   1         macSpiReadReg(SI4432_INTERRUPT_STATUS_1);
 556   1         macSpiReadReg(SI4432_INTERRUPT_STATUS_2);
 557   1         // enable TX
 558   1         macSetFunction1 (SI4432_TXON|SI4432_XTON);
 559   1              // start timer with packet transmit timeout
 560   1         macTimeout(TimeoutTX_Packet);
 561   1         EZMacProReg.name.MSR = TX_STATE_BIT | TX_STATE_WAIT_FOR_TX;
 562   1         //Call the TX state entered callback.
 563   1         EZMacPRO_StateTxEntered();
 564   1         ENABLE_MAC_INTERRUPTS();
 565   1      
 566   1         return MAC_OK;
 567   1      }
 568          #endif // RECEIVER_ONLY_OPERATION not defined
 569          //------------------------------------------------------------------------------------------------
 570          // Function Name : EZMacPRO_Receive()
 571          //                                               It starts searching for a new packet on the defined frequencies. If the receiver finds
 572          //                                               RF activity on a channel, it tries to receive and process the packet.
 573          //                                               The search can be stopped by the EZMacPRO_Idle() function.
 574          //                                               All the parameters have to be set before calling this function.
 575          //                                               EZMAC PRO has to be in IDLE mode when calling this function.
 576          //
 577          // Return Values : MAC_OK: the search mechanism started correctly.
 578          //                                               STATE_ERROR: the operation is ignored (the search mechanism has not been started) because the
 579          //                                                                                EZMAC PRO was not in IDLE mode.
 580          //-----------------------------------------------------------------------------------------------
 581          #ifndef TRANSMITTER_ONLY_OPERATION
 582          MacParams EZMacPRO_Receive(void)
 583          {
 584   1         U8 temp8;
 585   1      
 586   1         if (EZMacProReg.name.MSR != EZMAC_PRO_IDLE)
 587   1               return STATE_ERROR;
 588   1         else
 589   1         {
 590   2            DISABLE_MAC_INTERRUPTS();        // just in case
 591   2      #ifndef B1_ONLY
                              if(EZMacProReg.name.DTR == 0) //if the revV2 chip is used
                              {
                            //this register setting is needed (only rev V2)
                         macSpiWriteReg (SI4432_CRYSTAL_OSCILLATOR_CONTROL_TEST, 0x24);
                         //set the RX deviation (only rev V2)
                         macSpiWriteReg (SI4432_FREQUENCY_DEVIATION, RX_Freq_dev);
                              }
              #endif//B1_ONLY
 600   2      
 601   2      #ifdef FOUR_CHANNEL_IS_USED
 602   2            //Frequency search mechanism is disabled
 603   2            if((EZMacProReg.name.RCR & 0x04)== 0x00)
 604   2            {
 605   3                         //select the proper frequency register according to FSR register
 606   3                    temp8 = EZMacProReg.name.FSR;
 607   3                 if(temp8>3) temp8 = 0;
 608   3                              macSpiWriteReg (SI4432_FREQUENCY_HOPPING_CHANNEL_SELECT,EZMacProReg.array[FR0+temp8]);
C51 COMPILER V7.20   EZMACPRO                                                              04/10/2014 16:48:40 PAGE 11  

 609   3                 EZMacProCurrentChannel = temp8;
 610   3            }
 611   2            //Frequency search mechanism is enabled
 612   2            else
 613   2            {
 614   3               //select the first not masked frequency
 615   3               if ((EZMacProReg.name.RCR & 0x08) != 0x08) macSpiWriteReg (SI4432_FREQUENCY_HOPPING_CHANNEL_SELEC
             -T,EZMacProReg.name.FR0);
 616   3               else if ((EZMacProReg.name.RCR & 0x10) != 0x10) macSpiWriteReg (SI4432_FREQUENCY_HOPPING_CHANNEL_
             -SELECT,EZMacProReg.name.FR1);
 617   3               else if ((EZMacProReg.name.RCR & 0x20) != 0x20) macSpiWriteReg (SI4432_FREQUENCY_HOPPING_CHANNEL_
             -SELECT,EZMacProReg.name.FR2);
 618   3               else if ((EZMacProReg.name.RCR & 0x40) != 0x40) macSpiWriteReg (SI4432_FREQUENCY_HOPPING_CHANNEL_
             -SELECT,EZMacProReg.name.FR3);
 619   3            }
 620   2      #endif //FOUR_CHANNEL_IS_USED
 621   2      
 622   2            //disable Interrupt Enable 1
 623   2            macSpiWriteReg (SI4432_INTERRUPT_ENABLE_1, 0x00);
 624   2      
 625   2            //enable preamble valid interrupt
 626   2            macSetEnable2(SI4432_ENPREAVAL);
 627   2      
 628   2      #ifdef MORE_CHANNEL_IS_USED
                              SelectedChannel = 0;
                              macSpiWriteReg(SI4432_FREQUENCY_HOPPING_CHANNEL_SELECT,EZMacProReg.array[FR0+SelectedChannel]);
              #endif //MORE_CHANNEL_IS_USED
 632   2      
 633   2            // clear interrupt status
 634   2            macSpiReadReg(SI4432_INTERRUPT_STATUS_1);
 635   2            macSpiReadReg(SI4432_INTERRUPT_STATUS_2);
 636   2      
 637   2            // clear RX FIFO
 638   2            temp8 = macSpiReadReg (SI4432_OPERATING_AND_FUNCTION_CONTROL_2);
 639   2            temp8 |= SI4432_FFCLRRX;
 640   2            macSpiWriteReg (SI4432_OPERATING_AND_FUNCTION_CONTROL_2, temp8);
 641   2            temp8 &= ~SI4432_FFCLRRX;
 642   2            macSpiWriteReg (SI4432_OPERATING_AND_FUNCTION_CONTROL_2, temp8);
 643   2      
 644   2            // enable RX
 645   2            macSetFunction1(SI4432_RXON|SI4432_XTON);
 646   2                      // start timer with channel search timeout
 647   2                      macTimeout(TimeoutChannelSearch);
 648   2                      // go to next state
 649   2            EZMacProReg.name.MSR = RX_STATE_BIT | RX_STATE_FREQUENCY_SEARCH;
 650   2            //Call the RX state entered callback.
 651   2            EZMacPRO_StateRxEntered();
 652   2            ENABLE_MAC_INTERRUPTS();
 653   2      
 654   2            return MAC_OK;
 655   2      
 656   2         }
 657   1      }
 658          #endif // TRANSMITTER_ONLY_OPERATION
 659          //------------------------------------------------------------------------------------------------
 660          // Function Name:    EZMacPRO_Reg_Write
 661          //                                                      Writes the value into the register identified by name. MacRegs type is predefined;
 662          //                                                      the names of the available registers are listed in the Register Assignment section.
 663          //                                                      When required, this function also updates the radio register setting directly.
 664          //                                                      This function is also available to be called during SLEEP mode.
 665          //                                                      None of the registers can be set during packet transmission or reception!
 666          //
C51 COMPILER V7.20   EZMACPRO                                                              04/10/2014 16:48:40 PAGE 12  

 667          // Return Values:               MAC_OK: The register is set correctly.
 668          //                                                      NAME_ERROR: The register name is unknown.
 669          //                                                      VALUE_ERROR: The value is “out of the range: for this register.
 670          //                                                      STATE_ERROR: The requested operation is currently unavailable and ignored because either
 671          //                                                                                      transmission or reception is currently in progress.
 672          //                                                      INCONSISTENT_SETTING: If the data rate is changed and the current Frequency ID
 673          //                                                                                                              is not supported by the new data rate, the value of the
 674          //                                                                                                              inconsistent Frequency ID is automatically changed to a 0.
 675          //                                                                                                              In this case, the function returns with 'INCONSISTENT_SETTING'.
 676          //
 677          // Parameters   :    name: MAC register name
 678          //                      value: MAC register value
 679          //-----------------------------------------------------------------------------------------------
 680          MacParams EZMacPRO_Reg_Write(MacRegs  name, U8 value)
 681          {
 682   1         U8 temp8;
 683   1         U8 temp8_2;
 684   1      
 685   1         // register name check
 686   1            if (name>EZ_LASTREG)
 687   1               return NAME_ERROR;
 688   1      
 689   1         // state check
 690   1         if (EZMacProReg.name.MSR & (TX_STATE_BIT|RX_STATE_BIT))
 691   1            return STATE_ERROR;
 692   1      
 693   1         switch (name)
 694   1         {
 695   2                 // order must match enumerations
 696   2            // mandatory elements listed first
 697   2                      case    MCR:                          // Master Control Register
 698   2                              //Set the header length according to CID control bit
 699   2      #ifdef EXTENDED_PACKET_FORMAT
 700   2                      if (( value & 0x80 ) == 0x80)//if CID is used
 701   2                      //header length 4 byte(CTRL+CID+SID+DID)
 702   2                                 macSpiWriteReg(SI4432_HEADER_CONTROL_2, SI4432_HDLEN_4BYTE | (SYNC_WORD_LENGTH - 1) << 1);
 703   2                      else
 704   2                      //header length 3 byte(CTRL+SID+DID)
 705   2                      macSpiWriteReg(SI4432_HEADER_CONTROL_2, SI4432_HDLEN_3BYTE | (SYNC_WORD_LENGTH - 1 ) << 1);
 706   2      #else //STANDARD_PACKET_FORMAT
                              if (( value & 0x80 ) == 0x80)//if CID is used
                              //header length 3 byte(CID+SID+DID)
                              macSpiWriteReg(SI4432_HEADER_CONTROL_2, SI4432_HDLEN_3BYTE | (SYNC_WORD_LENGTH - 1) << 1);
                              else
                              //header length 2 byte(SID+DID)
                              macSpiWriteReg(SI4432_HEADER_CONTROL_2, SI4432_HDLEN_2BYTE | (SYNC_WORD_LENGTH - 1) << 1);
              #endif//EXTENDED_PACKET_FORMAT
 714   2      
 715   2               //Master Control Register(set modem, frequency parameters and preamble length according to the da
             -ta rate)
 716   2               SetRfParameters( value );
 717   2               macUpdateDynamicTimeouts(value, EZMacProReg.name.MPL);
 718   2      
 719   2      #ifdef FOUR_CHANNEL_IS_USED
 720   2                              //in case of four channel, check the frequency number is correct or not
 721   2                    temp8 = (value & 0x60) >> 5;
 722   2               if ( EZMacProReg.name.FR0 >= Parameters[temp8][MAX_CHANNEL_NUMBER])
 723   2               {
 724   3                  EZMacProReg.name.FR0 = 0;
 725   3                  return INCONSISTENT_SETTING;
 726   3               }
 727   2               if ( EZMacProReg.name.FR1 >= Parameters[temp8][MAX_CHANNEL_NUMBER])
C51 COMPILER V7.20   EZMACPRO                                                              04/10/2014 16:48:40 PAGE 13  

 728   2               {
 729   3                  EZMacProReg.name.FR1 = 0;
 730   3                  return INCONSISTENT_SETTING;
 731   3               }
 732   2               if ( EZMacProReg.name.FR2 >= Parameters[temp8][MAX_CHANNEL_NUMBER])
 733   2               {
 734   3                  EZMacProReg.name.FR2 = 0;
 735   3                  return INCONSISTENT_SETTING;
 736   3               }
 737   2      
 738   2               if ( EZMacProReg.name.FR3 >= Parameters[temp8][MAX_CHANNEL_NUMBER])
 739   2               {
 740   3                  EZMacProReg.name.FR3 = 0;
 741   3                  return INCONSISTENT_SETTING;
 742   3               }
 743   2      #endif //FOUR_CHANNEL_IS_USED
 744   2      #ifdef TRANSCEIVER_OPERATION
 745   2               macUpdateLBTI(EZMacProReg.name.LBTIR);
 746   2      #endif //TRANSCEIVER_OPERATION
 747   2               //static packet length used
 748   2               if (( value & 0x04 ) == 0x00)
 749   2               {
 750   3                  temp8 = macSpiReadReg(SI4432_HEADER_CONTROL_2);
 751   3                  macSpiWriteReg(SI4432_HEADER_CONTROL_2, temp8|SI4432_FIXPKLEN);
 752   3               }
 753   2      
 754   2               break;
 755   2            case    SECR:                         // State & Error Counter Control Register
 756   2               break;
 757   2            case    TCR:                          // Transmit Control Register
 758   2               //Transmit Control Register(set output power of the radio
 759   2                      temp8 = value >> 4;
 760   2      #ifndef B1_ONLY
                                      if(EZMacProReg.name.DTR == 0) //check the device typ
                                       macSpiWriteReg(SI4432_TX_POWER,temp8); // revV2
                                      else if(EZMacProReg.name.DTR == 1)
                                       macSpiWriteReg(SI4432_TX_POWER,(temp8|0x08)); //revA0
                                      else if(EZMacProReg.name.DTR == 2)
                                                      macSpiWriteReg(SI4432_TX_POWER,(temp8|0x18)); //revB1
              #endif//B1_ONLY
 768   2      #ifdef B1_ONLY
 769   2                              macSpiWriteReg(SI4432_TX_POWER,(temp8|0x18)); //revB1
 770   2      #endif//B1_ONLY
 771   2                      break;
 772   2               break;
 773   2            case    RCR:                          // Receiver Control Register
 774   2            //Receive Control Register
 775   2               if ((value & 0x78) == 0x78)
 776   2                  return VALUE_ERROR;
 777   2               break;
 778   2            case    FR0:                          // Frequency Register 0
 779   2               //break;
 780   2            case    FR1:                          // Frequency Register 1
 781   2               //break;
 782   2            case    FR2:                          // Frequency Register 2
 783   2               //break;
 784   2            case    FR3:                          // Frequency Register 3
 785   2               //break;
 786   2      #ifdef FOUR_CHANNEL_IS_USED
 787   2               //Frequency registers(check the setting value is correct)
 788   2               // /get the setting data rate
 789   2               temp8 = (EZMacProReg.name.MCR>>5)&0x03;
C51 COMPILER V7.20   EZMACPRO                                                              04/10/2014 16:48:40 PAGE 14  

 790   2               //check the enabled channel number
 791   2               if (value >=  Parameters[temp8][MAX_CHANNEL_NUMBER])
 792   2                  return VALUE_ERROR;
 793   2                              break;
 794   2      #endif //FOUR_CHANNEL_IS_USED
 795   2      
 796   2      #ifdef MORE_CHANNEL_IS_USED
                    case    FR4:                          // Frequency Register 4
                       //break;
                    case    FR5:                          // Frequency Register 5
                       //break;
                    case    FR6:                          // Frequency Register 6
                       //break;
                    case    FR7:                          // Frequency Register 7
                                      //break;
                    case    FR8:                          // Frequency Register 8
                       //break;
                    case    FR9:                          // Frequency Register 9
                       //break;
                    case    FR10:                         // Frequency Register 10
                       //break;
                    case    FR11:                         // Frequency Register 11
                                      //break;
                    case    FR12:                         // Frequency Register 12
                       //break;
                    case    FR13:                          // Frequency Register 13
                       //break;
                    case    FR14:                          // Frequency Register 14
                       //break;
                    case    FR15:                          // Frequency Register 15
                                      //break;
                    case    FR16:                          // Frequency Register 16
                       //break;
                    case    FR17:                          // Frequency Register 17
                       //break;
                    case    FR18:                          // Frequency Register 18
                       //break;
                    case    FR19:                          // Frequency Register 19
                                      //break;
                    case    FR20:                          // Frequency Register 20
                       //break;
                    case    FR21:                          // Frequency Register 21
                       //break;
                    case    FR22:                          // Frequency Register 22
                       //break;
                    case    FR23:                          // Frequency Register 23
                                      //break;
                    case    FR24:                          // Frequency Register 24
                       //break;
                    case    FR25:                          // Frequency Register 25
                       //break;
                    case    FR26:                          // Frequency Register 26
                       //break;
                    case    FR27:                          // Frequency Register 27
                                      //break;
                    case    FR28:                          // Frequency Register 28
                       //break;
                    case    FR29:                          // Frequency Register 29
                       //break;
                    case    FR30:                          // Frequency Register 30
                       //break;
                    case    FR31:                          // Frequency Register 31
C51 COMPILER V7.20   EZMACPRO                                                              04/10/2014 16:48:40 PAGE 15  

                                      //break;
                    case    FR32:                          // Frequency Register 32
                       //break;
                    case    FR33:                          // Frequency Register 33
                       //break;
                    case    FR34:                          // Frequency Register 34
                       //break;
                    case    FR35:                          // Frequency Register 35
                                      //break;
                    case    FR36:                          // Frequency Register 36
                       //break;
                    case    FR37:                          // Frequency Register 37
                       //break;
                    case    FR38:                          // Frequency Register 38
                       //break;
                    case    FR39:                          // Frequency Register 39
                                      //break;
                    case    FR40:                          // Frequency Register 40
                       //break;
                    case    FR41:                          // Frequency Register 41
                       //break;
                    case    FR42:                          // Frequency Register 42
                       //break;
                    case    FR43:                          // Frequency Register 43
                                      //break;
                    case    FR44:                          // Frequency Register 44
                       //break;
                    case    FR45:                          // Frequency Register 45
                       //break;
                    case    FR46:                          // Frequency Register 46
                       //break;
                    case    FR47:                          // Frequency Register 47
                                      //break;
                              case      FR48:                                                                 // Frequency Register 48
                                      //break;
                              case      FR49:                                                                 // Frequency Register 49
                                      break;
              #endif //MORE_CHANNEL_IS_USED
 890   2                      case      FSR:                                                                  // Frequency Select Register
 891   2      #ifdef FOUR_CHANNEL_IS_USED
 892   2                              if(value >= 4)
 893   2                                      return VALUE_ERROR;
 894   2      #endif
 895   2      #ifdef MORE_CHANNEL_IS_USED
                                      temp8 = (EZMacProReg.name.MCR >> 5) & 0x03;
                                      if(value >= Parameters[temp8] [5])
                                              return VALUE_ERROR;
              #endif
 900   2                              break;
 901   2      #ifdef FOUR_CHANNEL_IS_USED
 902   2                      case    EC0:                          // Error Counter of Frequency 0
 903   2               break;
 904   2            case    EC1:                          // Error Counter of Frequency 1
 905   2               break;
 906   2            case    EC2:                          // Error Counter of Frequency 2
 907   2               break;
 908   2            case    EC3:                          // Error Counter of Frequency 3
 909   2               break;
 910   2      #endif //FOUR_CHANNEL_IS_USED
 911   2            case    PFCR:                         // Packet Filter Control Register
 912   2               break;
 913   2            case    SFLT:                         // Sender ID Filter
C51 COMPILER V7.20   EZMACPRO                                                              04/10/2014 16:48:40 PAGE 16  

 914   2               break;
 915   2            case    SMSK:                         // Sender ID Filter Mask
 916   2               break;
 917   2            case    MCA_MCM:                      // Multicast Address / Multicast Mask
 918   2               break;
 919   2            case    MPL:                          // Maximum Packet Length
 920   2                if ( value > RECEIVED_BUFFER_SIZE )
 921   2                  return VALUE_ERROR;
 922   2               else
 923   2                  macUpdateDynamicTimeouts(EZMacProReg.name.MCR, value);          // max payload always updates 
             -timouts
 924   2               break;
 925   2            case    MSR:                          // MAC Status Register
 926   2               //MAC Status Register is read only
 927   2               return NAME_ERROR;
 928   2               break;
 929   2            case    RSR:                          // Receive Status Register
 930   2               //Receive Status Register is read only
 931   2               return NAME_ERROR;
 932   2               break;
 933   2                      case      RFSR:                                                         // Received Frequency Status Register
 934   2                    //Received Frequency Status Register is read only
 935   2               return NAME_ERROR;
 936   2               break;
 937   2      
 938   2            case    RSSI:                         // Received Signal Strength Indicator
 939   2               //Received Signal Strength Indicator is read  only
 940   2               return NAME_ERROR;
 941   2               break;
 942   2            case    SCID :                        // Self Customer ID
 943   2                              if (( EZMacProReg.name.MCR & 0x80 ) == 0x80)//if CID is used
 944   2                      //save the SCID to the Transmit Header3 register of the radio
 945   2                      macSpiWriteReg(SI4432_TRANSMIT_HEADER_3, value);
 946   2               else
 947   2                                      return NAME_ERROR;
 948   2               break;
 949   2            case    SFID:                         // Self ID
 950   2               if (value == 255)
 951   2                  return VALUE_ERROR;
 952   2                              if (( EZMacProReg.name.MCR & 0x80 ) == 0x80)//if CID is used
 953   2                      //save the SFID to the Transmit Header2 register of the radio
 954   2                      macSpiWriteReg(SI4432_TRANSMIT_HEADER_2, value);
 955   2                              else
 956   2                      //save the SFID to the Transmit Header3 register of the radio
 957   2                      macSpiWriteReg(SI4432_TRANSMIT_HEADER_3, value);
 958   2               break;
 959   2            case    RCTRL:                        // Received Control Byte
 960   2               //Received CTRL read only
 961   2               return NAME_ERROR;
 962   2               break;
 963   2            case    RCID:                         // Received Customer ID
 964   2               //Received Customer ID is read only
 965   2               return NAME_ERROR;
 966   2               break;
 967   2            case    RSID:                         // Received Sender ID
 968   2               //Received Sender ID is read only
 969   2               return NAME_ERROR;
 970   2               break;
 971   2            case    DID:                          // Destination ID
 972   2                              if (( EZMacProReg.name.MCR & 0x80 ) == 0x80)//if CID is used
 973   2                      //save the DID to the Transmit Header1 register of the radio
 974   2                      macSpiWriteReg(SI4432_TRANSMIT_HEADER_1, value);
C51 COMPILER V7.20   EZMACPRO                                                              04/10/2014 16:48:40 PAGE 17  

 975   2                              else
 976   2                      //save the DID to the Transmit Header2 register of the radio
 977   2                      macSpiWriteReg(SI4432_TRANSMIT_HEADER_2, value);
 978   2               break;
 979   2            case    PLEN:                         // Payload Length
 980   2               //set the payload length
 981   2               if ( value > RECEIVED_BUFFER_SIZE )
 982   2                  return VALUE_ERROR;
 983   2               else
 984   2               {
 985   3                  macSpiWriteReg(SI4432_TRANSMIT_PACKET_LENGTH,value);   //save the PLEN to the transmit packet 
             -length register
 986   3               }
 987   2               break;
 988   2      
 989   2            // optional elemets listed last using compiler switches
 990   2      #ifdef TRANSCEIVER_OPERATION
 991   2            case    LBTIR:                        // Listen Before Talk  Interval Register
 992   2               macUpdateLBTI(value);
 993   2               break;
 994   2            case    LBTLR:                        // Listen Before Talk Limit Register
 995   2               break;
 996   2      #endif //TRANSCEIVER_OPERATION
 997   2         case    LFTMR0:                       // Low Frequency Timer Setting Register 0
 998   2            //Low Frequency Timer Setting Register0
 999   2            macSpiWriteReg(SI4432_WAKE_UP_TIMER_PERIOD_3, value); //Set Wake-Up-Timer Mantissa
1000   2            break;
1001   2         case    LFTMR1:                       // Low Frequency Timer Setting Register 1
1002   2            //Low Frequency Timer Setting Register1
1003   2            macSpiWriteReg(SI4432_WAKE_UP_TIMER_PERIOD_2, value); //Set Wake-Up_Timer Mantissa
1004   2            break;
1005   2         case LFTMR2: // Low Frequency Timer Setting Register 2
1006   2              //Set Wake-Up_timer Exponent
1007   2              macSpiWriteReg(SI4432_WAKE_UP_TIMER_PERIOD_1, value & 0x3F);
1008   2              temp8 = macSpiReadReg(SI4432_INTERRUPT_ENABLE_2);
1009   2              temp8_2 = temp8 = macSpiReadReg(SI4432_OPERATING_AND_FUNCTION_CONTROL_1);
1010   2              if(value & 0x80)    //Wake-Up-Timer enabled
1011   2              {
1012   3                  temp8 |= SI4432_ENWUT;
1013   3                  temp8_2 |= SI4432_ENWT;
1014   3              }
1015   2              else                //Wake-Up-Timer disabled
1016   2              {
1017   3                  temp8 &= ~SI4432_ENWUT;
1018   3                  temp8_2 &= ~SI4432_ENWT;
1019   3              }
1020   2              macSpiWriteReg(SI4432_INTERRUPT_ENABLE_2, temp8);
1021   2              macSpiWriteReg(SI4432_OPERATING_AND_FUNCTION_CONTROL_1, temp8_2);
1022   2      
1023   2              temp8 = macSpiReadReg(SI4432_OPERATING_AND_FUNCTION_CONTROL_1);
1024   2              if(value & 0x40)    //Internal 32KHz RC Oscillator
1025   2              {
1026   3                  temp8 &= ~SI4432_X32KSEL;
1027   3              }
1028   2              else                //External 32KHz Oscillator
1029   2              {
1030   3                  temp8 |= SI4432_X32KSEL;
1031   3              }
1032   2              macSpiWriteReg(SI4432_OPERATING_AND_FUNCTION_CONTROL_1, temp8);
1033   2              ENABLE_MAC_EXT_INTERRUPT();
1034   2              break;
1035   2         case    LBDR:                         // Low Battery Detect Register
C51 COMPILER V7.20   EZMACPRO                                                              04/10/2014 16:48:40 PAGE 18  

1036   2            if ((value & 0x80) == 0x80)   //if enalbe the low battery detect
1037   2            {
1038   3                              temp8 = value & 0x1F;
1039   3                              macSpiWriteReg(SI4432_LOW_BATTERY_DETECTOR_THRESHOLD, temp8);     //set battery voltage threshold
1040   3      
1041   3                              temp8 = macSpiReadReg(SI4432_INTERRUPT_ENABLE_2);
1042   3               macSpiWriteReg(SI4432_INTERRUPT_ENABLE_2, temp8 | SI4432_ENLBDI);    //enable the low battery int
             -errupt
1043   3      
1044   3                              temp8 = macSpiReadReg(SI4432_OPERATING_AND_FUNCTION_CONTROL_1);
1045   3               macSpiWriteReg(SI4432_OPERATING_AND_FUNCTION_CONTROL_1, temp8|SI4432_ENLBD);
1046   3            }
1047   2                      else
1048   2                      {
1049   3                              temp8 = macSpiReadReg(SI4432_INTERRUPT_ENABLE_2);
1050   3               macSpiWriteReg(SI4432_INTERRUPT_ENABLE_2, temp8 & ~SI4432_ENLBDI);    //disable the low battery i
             -nterrupt
1051   3      
1052   3                              temp8 = macSpiReadReg(SI4432_OPERATING_AND_FUNCTION_CONTROL_1);
1053   3               macSpiWriteReg(SI4432_OPERATING_AND_FUNCTION_CONTROL_1, temp8 & ~SI4432_ENLBD); //disable the low
             - battery detect
1054   3                      }
1055   2            break;
1056   2         case    ADCTSR:                       // ADC and Temperature Sensor Register
1057   2                  //set ADC configuration register
1058   2            macSpiWriteReg(SI4432_ADC_CONFIGURATION, (value & 0xFC) | EZMACPRO_ADC_GAIN);
1059   2      
1060   2                      //set ADC sensor Amplifier register(EZMACPRO_ADC_AMP_OFFSET is definition in EZMacPro_defs.h)
1061   2            macSpiWriteReg(SI4432_ADC_SENSOR_AMPLIFIER_OFFSET, EZMACPRO_ADC_AMP_OFFSET);
1062   2            //set the Temperature Sensor range
1063   2            macSpiWriteReg(SI4432_TEMPERATURE_SENSOR_CONTROL, ((value & 0x03)<<6)|0x20);
1064   2            break;
1065   2      
1066   2         case    ADCTSV:                       // ADC/Temperature Value Register
1067   2            return NAME_ERROR;
1068   2            break;
1069   2              case      DTR:
1070   2      #ifndef B1_ONLY
                              if (value > 2)
                                      return VALUE_ERROR;
                              macSpecialRegisterSettings(value);
              #endif//B1_ONLY
1075   2                      break;
1076   2      
1077   2         }
1078   1         //Register update
1079   1         EZMacProReg.array[name] = value;
1080   1         return MAC_OK;
1081   1      
1082   1      }
1083          //------------------------------------------------------------------------------------------------
1084          // Function Name:    EZMacPRO_Reg_Read
1085          //                                              Gives back the value (over value pointer) of the register identified by name.
1086          //                                                      MacRegs type is predefined. This function may also be called in SLEEP mode.
1087          // Return Value :    MAC_OK: The operation was succesfull
1088          //                      NAME_ERROR: The register name is invalid
1089          //
1090          // Parameters   :    name: register name
1091          //                      value: register value
1092          //
1093          //
1094          //-----------------------------------------------------------------------------------------------
C51 COMPILER V7.20   EZMACPRO                                                              04/10/2014 16:48:40 PAGE 19  

1095          MacParams EZMacPRO_Reg_Read (MacRegs name, U8 *value)
1096          {
1097   1      
1098   1              // register name check
1099   1         if (name>EZ_LASTREG)
1100   1            return NAME_ERROR;
1101   1      
1102   1         //this 3 registers are write only
1103   1         if ((name == LFTMR0) || (name == LFTMR1) ||(name == LFTMR2))
1104   1         {
1105   2            return NAME_ERROR;
1106   2         }
1107   1      
1108   1         if (name == RSSI)
1109   1            // state check
1110   1            if ((EZMacProReg.name.MSR & RX_STATE_BIT)==RX_STATE_BIT)
1111   1               //if the MAC in these state then the RSSI will be read from the chip
1112   1               EZMacProReg.name.RSSI = macSpiReadReg(SI4432_RECEIVED_SIGNAL_STRENGTH_INDICATOR);
1113   1      
1114   1      
1115   1              if (name == ADCTSV)
1116   1              {
1117   2              EZMacProReg.name.ADCTSV = macSpiReadReg(SI4432_ADC_VALUE);
1118   2              }
1119   1      
1120   1              if (name == LBDR)
1121   1                      if ((EZMacProReg.name.LBDR & 0x80) == 0x80)
1122   1                      {
1123   2                              EZMacProReg.name.LBDR &= 0x80;
1124   2                              EZMacProReg.name.LBDR |= macSpiReadReg(SI4432_BATTERY_VOLTAGE_LEVEL);
1125   2      
1126   2                      }
1127   1                      else EZMacProReg.name.LBDR = 0x00;
1128   1      
1129   1      
1130   1        // gives back the register content
1131   1        *value = EZMacProReg.array[name];
1132   1        return MAC_OK;
1133   1      }
1134          
1135          //------------------------------------------------------------------------------------------------
1136          // Function Name: EZMacPRO_TxBuf_Write
1137          //                                              The function copies length number of payload bytes into the transmit FIFO of the radio chip.
1138          //                                              There is no dedicated transmit buffer in the source code.Upon calling this function,
1139          //                                              it clears the TX FIFO of the radio first.If variable packet length is used and
1140          //                                              the length is not greater than the RECEIVED_BUFFER_SIZE definition
1141          //                                              (it cannot be greater than 64), then EZMAC PRO copies length number of payload
1142          //                                              bytes into the TX FIFO of the radio, sets the PLEN register of EZMAC PRO,
1143          //                                              and also sets the packet length register of the radio. If fix packet length is used,
1144          //                                              then the PLEN register has to set first, because the function copies only
1145          //                                              Payload Length number of bytes into the FIFO even if the length is greater.
1146          //                                              Also it fills the FIFO with extra 0x00 bytes if the length is smaller than
1147          //                                              the value of the Payload Length register in fix packet length mode.
1148          //                                              The function cannot be called during transmission and reception.
1149          //
1150          // Return Values:   MAC_OK: The operation performed correctly.
1151          //                  STATE_ERROR: The operation is ignored because transmission and reception are in progre
             -ss.
1152          //
1153          // Parameters:      length: payload length
1154          //                  payload: payload content
1155          //
C51 COMPILER V7.20   EZMACPRO                                                              04/10/2014 16:48:40 PAGE 20  

1156          //-----------------------------------------------------------------------------------------------
1157          #ifndef RECEIVER_ONLY_OPERATION
1158          MacParams EZMacPRO_TxBuf_Write(U8 length, VARIABLE_SEGMENT_POINTER(payload, U8, BUFFER_MSPACE))
1159          {
1160   1         U8 temp8;
1161   1      
1162   1         // state check
1163   1         if (EZMacProReg.name.MSR & (TX_STATE_BIT|RX_STATE_BIT))
1164   1            return STATE_ERROR;
1165   1      
1166   1         // if the given packet is bigger then the RECEIVED_BUFFER_SIZE
1167   1         if ( length > RECEIVED_BUFFER_SIZE )
1168   1            return VALUE_ERROR;
1169   1      
1170   1         // clear TX FIFO
1171   1         temp8 = macSpiReadReg (SI4432_OPERATING_AND_FUNCTION_CONTROL_2);
1172   1         temp8 |= SI4432_FFCLRTX;
1173   1         macSpiWriteReg (SI4432_OPERATING_AND_FUNCTION_CONTROL_2, temp8);
1174   1         temp8 &= ~SI4432_FFCLRTX;
1175   1         macSpiWriteReg (SI4432_OPERATING_AND_FUNCTION_CONTROL_2, temp8);
1176   1      
1177   1      
1178   1         //if dynamic payload length mode is set
1179   1         if ((EZMacProReg.name.MCR & 0x04) == 0x04)
1180   1         {
1181   2      
1182   2            //set the transmit packet length
1183   2            macSpiWriteReg(SI4432_TRANSMIT_PACKET_LENGTH, length);
1184   2            EZMacProReg.name.PLEN = length;
1185   2            //set the payload content
1186   2            macSpiWriteFIFO(length,payload);
1187   2         }
1188   1         //if static payload length mode is set
1189   1         else
1190   1         {
1191   2      
1192   2            if (length < EZMacProReg.name.PLEN) //if payload length smaller than the fix payload length
1193   2            {
1194   3               //set the payload content
1195   3               macSpiWriteFIFO(length,payload);
1196   3      
1197   3               //fill the remain payload bytes with zero
1198   3               for(temp8=length;temp8 < EZMacProReg.name.PLEN;temp8++)
1199   3                  macSpiWriteReg(SI4432_FIFO_ACCESS,0x00);
1200   3      
1201   3            }
1202   2            else  //if the payload length equal or bigger than the fix payload length
1203   2            {
1204   3               macSpiWriteFIFO(EZMacProReg.name.PLEN,payload);
1205   3            }
1206   2      
1207   2      
1208   2         }
1209   1         return MAC_OK;
1210   1      }
1211          #endif //RECEIVER_ONLY_OPERATION not defined
1212          
1213          //------------------------------------------------------------------------------------------------
1214          // Function Name: EZMacPRO_RxBuf_Read
1215          //                                              After a successful packet reception EZMAC PRO copies the received data bytes into
1216          //                                              the receive data buffer. The receive data buffer is declared in the EZMacPro.c file as
1217          //                                              SEGMENT_VARIABLE(RxBuffer[RECEIVED_BUFFER_SIZE], U8, BUFFER_MSPACE);
C51 COMPILER V7.20   EZMACPRO                                                              04/10/2014 16:48:40 PAGE 21  

1218          //                                              The length of the receive buffer is defined by the RECEIVED_BUFFER_SIZE definition in the
1219          //                                              EZMacPro_defs.h. It can be adjusted for the application needs, but it can not be greater than 64by
             -tes.
1220          //                                              The receive buffer is declared to be placed into the XDATA memory, it also can be adjusted by
1221          //                                              changing the BUFFER_MSPACE definition. Upon calling the EZMacPRO_RxBuf_Read() function, it
1222          //                                              copies received data from the receive data buffer to payload. Also it gives back the number of
1223          //                                              received bytes by length.
1224          //                                              The function cannot be called during transmission and reception.
1225          //
1226          // Return Values:   MAC_OK: The operation was succesfull
1227          //                  STATE_ERROR: The operation is ignored, because reception or transmission is ongoing.
1228          //
1229          // Parameters:      length: received payload length
1230          //                  payload: received payload content
1231          //
1232          //-----------------------------------------------------------------------------------------------
1233          #ifndef TRANSMITTER_ONLY_OPERATION
1234          MacParams EZMacPRO_RxBuf_Read(VARIABLE_SEGMENT_POINTER(length, U8, BUFFER_MSPACE), VARIABLE_SEGMENT_POINTE
             -R(payload, U8, BUFFER_MSPACE))
1235          {
1236   1         U8 temp8 = 0;
1237   1      
1238   1         *length = EZMacProReg.name.PLEN;
1239   1      
1240   1         while(temp8 < EZMacProReg.name.PLEN)
1241   1         {
1242   2            *payload++ = RxBuffer[temp8];
1243   2            temp8++;
1244   2         }
1245   1         return MAC_OK;
1246   1      }
1247          #endif // TRANSMITTER_ONLY_OPERATION not defined
1248          
1249          //------------------------------------------------------------------------------------------------
1250          // Function Name:   EZMacPRO_Ack_Write()
1251          //
1252          //                  The function copies length number of bytes into the Acknowledgement buffer.
1253          //                  Length should not be greater than ACK_BUFFER_SIZE otherwise STATE_ERROR is returned.
1254          //                  In dynamic packet length mode the payload size is set to length.
1255          //                  In fixed packet length mode, if length is smaller than PLEN, then the remaining bytes
1256          //                  are filled with zeros. Otherwise only PLEN number of bytes are copied.
1257          //                  The function should exclusively be used in the EZMacPRO_AckSending() callback to
1258          //                  put custom data in the AckBuffer just before its content is pushed into the transmit
1259          //                  FIFO.
1260          //
1261          // Return Values:   MAC_OK: The operation performed correctly.
1262          //                  STATE_ERROR: The operation is ignored as the statemachine is not in receive state.
1263          //
1264          // Parameters:      length: payload length
1265          //                  payload: payload content
1266          //
1267          //-----------------------------------------------------------------------------------------------
1268          #ifdef TRANSCEIVER_OPERATION
1269          #ifdef EXTENDED_PACKET_FORMAT
1270          MacParams EZMacPRO_Ack_Write(U8 length, VARIABLE_SEGMENT_POINTER(payload, U8, BUFFER_MSPACE))
1271          {
1272   1          U8 temp8 = 0;
1273   1      
1274   1          // state check: if not in RX state -> error
1275   1          if (!(EZMacProReg.name.MSR & RX_STATE_BIT))
1276   1              return STATE_ERROR;
1277   1      
C51 COMPILER V7.20   EZMACPRO                                                              04/10/2014 16:48:40 PAGE 22  

1278   1          //if length is bigger than the ACK_BUFFER_SIZE
1279   1          if (length > ACK_BUFFER_SIZE)
1280   1              return VALUE_ERROR;
1281   1      
1282   1          //if dynamic payload length mode is set
1283   1          if ((EZMacProReg.name.MCR & 0x04) == 0x04)
1284   1          {
1285   2              //set the transmit packet length
1286   2              macSpiWriteReg(SI4432_TRANSMIT_PACKET_LENGTH,length);
1287   2      
1288   2              //load AckBuffer
1289   2              for(temp8 = 0; temp8 < length; temp8++)
1290   2                  AckBuffer[temp8] = payload[temp8];
1291   2          }
1292   1          else//if static payload length mode is set
1293   1          {
1294   2              //if fix packet length is greater than ack buffer size
1295   2              if(EZMacProReg.name.PLEN > ACK_BUFFER_SIZE)
1296   2              {
1297   3                  //load AckBuffer
1298   3                  for(temp8 = 0; temp8 < length; temp8++)
1299   3                      AckBuffer[temp8] = payload[temp8];
1300   3                  //fill the remaining bytes with zero
1301   3                  for(temp8 = length; temp8 < ACK_BUFFER_SIZE; temp8++)
1302   3                      AckBuffer[temp8] = 0x00;
1303   3              }
1304   2              else//if fix packet length is smaller or equal than ack buffer size
1305   2              {
1306   3                  //if payload length smaller than the fix payload length
1307   3                  if (length < EZMacProReg.name.PLEN)
1308   3                  {
1309   4                      //load AckBuffer
1310   4                      for(temp8 = 0; temp8 < length; temp8++)
1311   4                          AckBuffer[temp8] = payload[temp8];
1312   4                      //fill the remaining bytes with zero
1313   4                      for(temp8 = length; temp8 < EZMacProReg.name.PLEN; temp8++)
1314   4                          AckBuffer[temp8] = 0x00;
1315   4                  }
1316   3                  else //if the payload length equal or bigger than the fix payload length
1317   3                  {
1318   4                      //load AckBuffer
1319   4                      for(temp8 = 0; temp8 < EZMacProReg.name.PLEN; temp8++)
1320   4                          AckBuffer[temp8] = payload[temp8];
1321   4                  }
1322   3              }
1323   2         }
1324   1         return MAC_OK;
1325   1      }
1326          #endif //EXTENDED_PACKET_FORMAT not defined
1327          #endif //TRANSCEIVER_OPERATION not defined
1328          
1329          
1330                          /* ======================================= *
1331                           *      L O C A L   F U N C T I O N S      *
1332                           * ======================================= */
1333          
1334          //------------------------------------------------------------------------------------------------
1335          // Function Name: SetRfParameters
1336          //
1337          // Return Value : None
1338          // Parameters   : mcr: Master Control Register value
1339          //
C51 COMPILER V7.20   EZMACPRO                                                              04/10/2014 16:48:40 PAGE 23  

1340          // Note: Set the modem, frequency parameters and preamble according to data rate
1341          //
1342          //-----------------------------------------------------------------------------------------------
1343          void SetRfParameters(U8 mcr)
1344          {
1345   1         U8 dataRate;
1346   1         U8 numFreq;
1347   1      #ifdef MORE_CHANNEL_IS_USED
                      U8 temp8;
              #endif//MORE_CHANNEL_IS_USED
1350   1         dataRate = (mcr >> 5) & 0x03;
1351   1         numFreq = mcr & 0x03;
1352   1      #ifndef B1_ONLY
                 //set the modem parameters
                      switch(EZMacProReg.name.DTR)
                      {
                              case 0://rev V2
                                      macSpiWriteReg(SI4432_IF_FILTER_BANDWIDTH, RfSettingsV2[dataRate][0] );
                                 macSpiWriteReg(SI4432_CLOCK_RECOVERY_OVERSAMPLING_RATIO, RfSettingsV2[dataRate][1]);
                                 macSpiWriteReg(SI4432_CLOCK_RECOVERY_OFFSET_2, RfSettingsV2[dataRate][2]);
                                 macSpiWriteReg(SI4432_CLOCK_RECOVERY_OFFSET_1, RfSettingsV2[dataRate][3]);
                                 macSpiWriteReg(SI4432_CLOCK_RECOVERY_OFFSET_0, RfSettingsV2[dataRate][4]);
                                 macSpiWriteReg(SI4432_CLOCK_RECOVERY_TIMING_LOOP_GAIN_1, RfSettingsV2[dataRate][5]);
                                 macSpiWriteReg(SI4432_CLOCK_RECOVERY_TIMING_LOOP_GAIN_0, RfSettingsV2[dataRate][6]);
                                 macSpiWriteReg(SI4432_TX_DATA_RATE_1, RfSettingsV2[dataRate][7]);
                                 macSpiWriteReg(SI4432_TX_DATA_RATE_0, RfSettingsV2[dataRate][8]);
                                 macSpiWriteReg(SI4432_MODULATION_MODE_CONTROL_1,RfSettingsV2[dataRate][9]);
                                      macSpiWriteReg(SI4432_FREQUENCY_DEVIATION,RfSettingsV2[dataRate][10]);
                              macSpiWriteReg(SI4432_AFC_LOOP_GEARSHIFT_OVERRIDE, RfSettingsV2[dataRate][12]);
                              macSpiWriteReg(SI4432_CHARGEPUMP_CURRENT_TRIMMING_OVERRIDE, RfSettingsV2[dataRate][13]);
              #ifndef RECEIVER_ONLY_OPERATION
                              TX_Freq_dev = RfSettingsV2[dataRate][10];
              #endif//RECEIVER_ONLY_OPERATION
              #ifndef TRANSMITTER_ONLY_OPERATION
                                      RX_Freq_dev = RfSettingsV2[dataRate][11];
              #endif//TRANSMITTER_ONLY_OPERATION
                              macSpiWriteReg(SI4432_PREAMBLE_DETECTION_CONTROL, Parameters[dataRate][PREAMBLE_DETECTION_THRESHOLD]<
             -<3);
                                      break;
                              case 1://rev A0
                                 macSpiWriteReg(SI4432_IF_FILTER_BANDWIDTH, RfSettingsA0[dataRate][0] );
                              macSpiWriteReg(SI4432_CLOCK_RECOVERY_OVERSAMPLING_RATIO, RfSettingsA0[dataRate][1]);
                              macSpiWriteReg(SI4432_CLOCK_RECOVERY_OFFSET_2, RfSettingsA0[dataRate][2]);
                                 macSpiWriteReg(SI4432_CLOCK_RECOVERY_OFFSET_1, RfSettingsA0[dataRate][3]);
                                 macSpiWriteReg(SI4432_CLOCK_RECOVERY_OFFSET_0, RfSettingsA0[dataRate][4]);
                                 macSpiWriteReg(SI4432_CLOCK_RECOVERY_TIMING_LOOP_GAIN_1, RfSettingsA0[dataRate][5]);
                                 macSpiWriteReg(SI4432_CLOCK_RECOVERY_TIMING_LOOP_GAIN_0, RfSettingsA0[dataRate][6]);
                                 macSpiWriteReg(SI4432_TX_DATA_RATE_1, RfSettingsA0[dataRate][7]);
                                 macSpiWriteReg(SI4432_TX_DATA_RATE_0, RfSettingsA0[dataRate][8]);
                                 macSpiWriteReg(SI4432_MODULATION_MODE_CONTROL_1,RfSettingsA0[dataRate][9]);
                                      macSpiWriteReg(SI4432_FREQUENCY_DEVIATION,RfSettingsA0[dataRate][10]);
                              macSpiWriteReg(SI4432_AFC_LOOP_GEARSHIFT_OVERRIDE, RfSettingsA0[dataRate][12]);
                              macSpiWriteReg(SI4431_AFC_LIMIT, RfSettingsA0[dataRate][13]);
                              macSpiWriteReg(SI4432_PREAMBLE_DETECTION_CONTROL, (Parameters[dataRate][PREAMBLE_DETECTION_THRESHOLD]
             -<<3)|0x02);
                                      break;
                              case 2: //rev B1
                              default:
                                 macSpiWriteReg(SI4432_IF_FILTER_BANDWIDTH, RfSettingsB1[dataRate][0] );
                                      macSpiWriteReg(SI4432_CLOCK_RECOVERY_OVERSAMPLING_RATIO, RfSettingsB1[dataRate][1]);
                                      macSpiWriteReg(SI4432_CLOCK_RECOVERY_OFFSET_2, RfSettingsB1[dataRate][2]);
                              macSpiWriteReg(SI4432_CLOCK_RECOVERY_OFFSET_1, RfSettingsB1[dataRate][3]);
C51 COMPILER V7.20   EZMACPRO                                                              04/10/2014 16:48:40 PAGE 24  

                                      macSpiWriteReg(SI4432_CLOCK_RECOVERY_OFFSET_0, RfSettingsB1[dataRate][4]);
                              macSpiWriteReg(SI4432_CLOCK_RECOVERY_TIMING_LOOP_GAIN_1, RfSettingsB1[dataRate][5]);
                              macSpiWriteReg(SI4432_CLOCK_RECOVERY_TIMING_LOOP_GAIN_0, RfSettingsB1[dataRate][6]);
                              macSpiWriteReg(SI4432_TX_DATA_RATE_1, RfSettingsB1[dataRate][7]);
                              macSpiWriteReg(SI4432_TX_DATA_RATE_0, RfSettingsB1[dataRate][8]);
                              macSpiWriteReg(SI4432_MODULATION_MODE_CONTROL_1,RfSettingsB1[dataRate][9]);
                                      macSpiWriteReg(SI4432_FREQUENCY_DEVIATION,RfSettingsB1[dataRate][10]);
                              macSpiWriteReg(SI4432_AFC_LOOP_GEARSHIFT_OVERRIDE, RfSettingsB1[dataRate][12]);
                              macSpiWriteReg(SI4431_AFC_LIMIT, RfSettingsB1[dataRate][13]);
                                      macSpiWriteReg(SI4432_AFC_TIMING_CONTROL, RfSettingsB1[dataRate][14]);
                              macSpiWriteReg(SI4432_PREAMBLE_DETECTION_CONTROL, (Parameters[dataRate][PREAMBLE_DETECTION_THRESHOLD]
             -<<3)|0x02);
                                      break;
                      }
              #endif//B1_ONLY
1414   1      #ifdef B1_ONLY
1415   1         macSpiWriteReg(SI4432_IF_FILTER_BANDWIDTH, RfSettingsB1[dataRate][0] );
1416   1              macSpiWriteReg(SI4432_CLOCK_RECOVERY_OVERSAMPLING_RATIO, RfSettingsB1[dataRate][1]);
1417   1              macSpiWriteReg(SI4432_CLOCK_RECOVERY_OFFSET_2, RfSettingsB1[dataRate][2]);
1418   1              macSpiWriteReg(SI4432_CLOCK_RECOVERY_OFFSET_1, RfSettingsB1[dataRate][3]);
1419   1              macSpiWriteReg(SI4432_CLOCK_RECOVERY_OFFSET_0, RfSettingsB1[dataRate][4]);
1420   1              macSpiWriteReg(SI4432_CLOCK_RECOVERY_TIMING_LOOP_GAIN_1, RfSettingsB1[dataRate][5]);
1421   1              macSpiWriteReg(SI4432_CLOCK_RECOVERY_TIMING_LOOP_GAIN_0, RfSettingsB1[dataRate][6]);
1422   1              macSpiWriteReg(SI4432_TX_DATA_RATE_1, RfSettingsB1[dataRate][7]);
1423   1              macSpiWriteReg(SI4432_TX_DATA_RATE_0, RfSettingsB1[dataRate][8]);
1424   1              macSpiWriteReg(SI4432_MODULATION_MODE_CONTROL_1,RfSettingsB1[dataRate][9]);
1425   1              macSpiWriteReg(SI4432_FREQUENCY_DEVIATION,RfSettingsB1[dataRate][10]);
1426   1              macSpiWriteReg(SI4432_AFC_LOOP_GEARSHIFT_OVERRIDE, RfSettingsB1[dataRate][12]);
1427   1              macSpiWriteReg(SI4431_AFC_LIMIT, RfSettingsB1[dataRate][13]);
1428   1              macSpiWriteReg(SI4432_AFC_TIMING_CONTROL, RfSettingsB1[dataRate][14]);
1429   1              macSpiWriteReg(SI4432_PREAMBLE_DETECTION_CONTROL, (Parameters[dataRate][PREAMBLE_DETECTION_THRESHOLD]<<
             -3)|0x02);
1430   1      #endif//B1_ONLY
1431   1         //set frequency parameters (center frequency and frequency hopping step size)
1432   1         macSpiWriteReg(SI4432_FREQUENCY_BAND_SELECT, Parameters[dataRate][START_FREQUENCY_1]);
1433   1         macSpiWriteReg(SI4432_NOMINAL_CARRIER_FREQUENCY_1, Parameters[dataRate][START_FREQUENCY_2]);
1434   1         macSpiWriteReg(SI4432_NOMINAL_CARRIER_FREQUENCY_0, Parameters[dataRate][START_FREQUENCY_3]);
1435   1         macSpiWriteReg(SI4432_FREQUENCY_HOPPING_STEP_SIZE, Parameters[dataRate][STEP_FREQUENCY]);
1436   1      
1437   1      #ifdef MORE_CHANNEL_IS_USED
                      macSpiWriteReg(SI4432_PLL_TUNE_TIME, Parameters[dataRate][PLL_TUNE_TIME_REG_VALUE]);
              #endif
1440   1      
1441   1         //set preamble length according to number of used channel
1442   1      #ifdef FOUR_CHANNEL_IS_USED
1443   1         if (numFreq == 0)
1444   1         {
1445   2            //if one channel is used
1446   2            macSpiWriteReg(SI4432_PREAMBLE_LENGTH, (Parameters[dataRate][PREAMBLE_IF_ONE_CHANNEL])<<1);
1447   2         }
1448   1         else if (numFreq == 1)
1449   1         {
1450   2            //if two channel is used
1451   2            macSpiWriteReg(SI4432_PREAMBLE_LENGTH, (Parameters[dataRate][PREAMBLE_IF_TWO_CHANNEL])<<1);
1452   2         }
1453   1         else if (numFreq == 2)
1454   1         {
1455   2            //if three channel is used
1456   2            macSpiWriteReg(SI4432_PREAMBLE_LENGTH, (Parameters[dataRate][PREAMBLE_IF_THREE_CHANNEL])<<1);
1457   2         }
1458   1         else // default four channels
1459   1         {
C51 COMPILER V7.20   EZMACPRO                                                              04/10/2014 16:48:40 PAGE 25  

1460   2            //if four channel is used
1461   2            macSpiWriteReg(SI4432_PREAMBLE_LENGTH, (Parameters[dataRate][PREAMBLE_IF_FOUR_CHANNEL])<<1);
1462   2         }
1463   1      #endif//FOUR_CHANNEL_IS_USED
1464   1      #ifdef MORE_CHANNEL_IS_USED
                              maxChannelNumber = Parameters[dataRate][CHANNEL_NUMBERS];
                              temp8 = macSpiReadReg(SI4432_HEADER_CONTROL_2);
                              macSpiWriteReg(SI4432_HEADER_CONTROL_2, (temp8 | Parameters[dataRate][PREAMBLE_LENGTH_REG_VALUE1]));
                    macSpiWriteReg(SI4432_PREAMBLE_LENGTH, Parameters[dataRate][PREAMBLE_LENGTH_REG_VALUE2]);
              #endif//MORE_CHANNEL_IS_USED
1470   1      
1471   1      }
1472          
1473          //------------------------------------------------------------------------------------------------
1474          // Function Name: macSpecialRegisterSettings
1475          //
1476          // Return Value : None
1477          // Parameters   : chiptype - Device Type Register value
1478          //
1479          //
1480          //-----------------------------------------------------------------------------------------------
1481          void macSpecialRegisterSettings(U8 chiptype)
1482          {
1483   1      
1484   1              switch(chiptype)
1485   1              {
1486   2      #ifndef B1_ONLY
                              case 0://rev V2
                                 //these settings need for good RF link(V2 specific settings)
                                 macSpiWriteReg(SI4432_CLOCK_RECOVERY_GEARSHIFT_OVERRIDE, 0x03);
                                      //set VCO
                              macSpiWriteReg(SI4432_VCO_CURRENT_TRIMMING, 0x7F);
                              macSpiWriteReg(SI4432_DIVIDER_CURRENT_TRIMMING, 0x40);
                              //set the AGC
                              macSpiWriteReg(SI4432_AGC_OVERRIDE_2, 0x0B);
                              //set ADC reference voltage to 0.9V
                              macSpiWriteReg(SI4432_DELTASIGMA_ADC_TUNING_2, 0x04);
                                 //set the crystal capacitance bank
                                      macSpiWriteReg(SI4432_CRYSTAL_OSCILLATOR_LOAD_CAPACITANCE, 0xDD);
                                      break;
                              case 1: //rev A0
                                 //set VCO
                                 macSpiWriteReg(SI4432_VCO_CURRENT_TRIMMING, 0x01);
                                 macSpiWriteReg(SI4432_DIVIDER_CURRENT_TRIMMING, 0x00);
              
                              macSpiWriteReg(SI4432_CHARGEPUMP_TEST, 0x01);
                              //set the Modem test register
                              macSpiWriteReg(SI4432_MODEM_TEST, 0xC1);
                                 //set the crystal capacitance bank
                                      macSpiWriteReg(SI4432_CRYSTAL_OSCILLATOR_LOAD_CAPACITANCE, 0xDD);
                                      break;
              #endif //B1_ONLY
1512   2                      case 2:
1513   2                      default:        //rev B1
1514   2                              // Set AGC Override1 Register
1515   2                      macSpiWriteReg(SI4432_AGC_OVERRIDE_1, 0x60);
1516   2                              //set the crystal capacitance bank
1517   2                              macSpiWriteReg(SI4432_CRYSTAL_OSCILLATOR_LOAD_CAPACITANCE, 0x6D);
1518   2                              break;
1519   2              }
1520   1      }
1521          //------------------------------------------------------------------------------------------------
C51 COMPILER V7.20   EZMACPRO                                                              04/10/2014 16:48:40 PAGE 26  

1522          // Function Name: macUpdateDynamicTimeouts
1523          //                                              This function calculate all of the timeouts for the EZMac stack.
1524          //
1525          // Return Value : None
1526          // Parameters   : mcr - Master Control Register value
1527          //                                              mpl - Maximum Payload size
1528          //------------------------------------------------------------------------------------------------
1529          void macUpdateDynamicTimeouts(U8 mcr, U8 mpl)
1530          {
1531   1          U16 n;
1532   1          U8 preamble;
1533   1          S8 header;
1534   1          U16 byteTime;
1535   1      
1536   1          // look up byte time
1537   1          n = ((mcr >> 5) & 0x03);
1538   1          byteTime = EZMacProByteTime[n];
1539   1      
1540   1          //determine the preamble length
1541   1      #ifdef FOUR_CHANNEL_IS_USED
1542   1          preamble = Parameters[n][PREAMBLE_IF_ONE_CHANNEL + (mcr & 0x03)];
1543   1      #endif //FOUR_CHANNEL_IS_USED
1544   1      #ifdef MORE_CHANNEL_IS_USED
                  preamble = Parameters[n][PREAMBLE_LENGTH];
              #endif //MORE_CHANNEL_IS_USED
1547   1      
1548   1          //determine the header length
1549   1      #ifdef STANDARD_PACKET_FORMAT
                  if(mcr & 0x80)      //if CID is used
                  {
                      header = 3;     //CID+SID+DID
                  }
                  else
                  {
                      header = 2;     //SID+DID
                  }
              #endif //STANDARD_PACKET_FORMAT
1559   1      #ifdef EXTENDED_PACKET_FORMAT
1560   1          if(mcr & 0x80)      //if CID is used
1561   1          {
1562   2              header = 4;     //CTRL+CID+SID+DID
1563   2          }
1564   1          else
1565   1          {
1566   2              header = 3;     //CTRL+SID+DID
1567   2          }
1568   1      #endif //EXTENDED_PACKET_FORMAT
1569   1      
1570   1          //if DNPL
1571   1          if (mcr & 0x04)
1572   1          {
1573   2              header++;       //add one for length
1574   2          }
1575   1      
1576   1      #ifndef TRANSMITTER_ONLY_OPERATION
1577   1          //update the sync word timeout
1578   1          TimeoutSyncWord = (preamble + 2) * (U32)byteTime;
1579   1          //update the channel search timeout
1580   1      #ifdef FOUR_CHANNEL_IS_USED
1581   1          TimeoutChannelSearch = (byteTime) * Parameters[n][SEARCH_TIME];
1582   1      #endif//FOUR_CHANNEL_IS_USED
1583   1      #ifdef MORE_CHANNEL_IS_USED
C51 COMPILER V7.20   EZMACPRO                                                              04/10/2014 16:48:40 PAGE 27  

                  TimeoutChannelSearch = (byteTime/8) * Parameters[n][SEARCH_TIME];
              #endif//MORE_CHANNEL_IS_USED
1586   1      
1587   1          // calculate TimeoutRX_Packet using mpl
1588   1          n = (U8)header + mpl + 2 + 3;
1589   1          TimeoutRX_Packet = n * (U32)(byteTime);
1590   1      #endif //TRANSMITTER_ONLY_OPERATION
1591   1      #ifndef RECEIVER_ONLY_OPERATION
1592   1          // calculate TimeoutTX_Packet using MPL
1593   1          n = preamble + SYNC_WORD_LENGTH + (U8)header + mpl + 2 + 8;
1594   1          TimeoutTX_Packet = n * (U32)(byteTime);
1595   1      #endif
1596   1      
1597   1      #ifdef EXTENDED_PACKET_FORMAT
1598   1          // if DNPL
1599   1          if ((mcr & 0x04) == 0x04)
1600   1          {
1601   2              // use fixed one byte payload for ACK
1602   2              //mpl = 1;
1603   2              // use ACK_BUFFER_SIZE for calculation of TimeoutACK
1604   2              mpl = ACK_BUFFER_SIZE;
1605   2          }
1606   1      
1607   1          n = preamble + SYNC_WORD_LENGTH + (U8)header + mpl + 2 + 3;
1608   1          //ACK time out: the SW make up the ACK packet(in 4 Mhz ~1.6ms) + 200 us(PLL settling time) + n * byte 
             -time
1609   1          TimeoutACK = (n * (U32)(byteTime));
1610   1          TimeoutACK += (U32)(MAKE_UP_THE_ACK_PACKET + PLL_SETTLING_TIME);
1611   1      
1612   1      #ifdef PACKET_FORWARDING_SUPPORTED
                  // use n for radius
                  n = (mcr & 0x18) >> 3;
              
                  if (n)
                  {
                      TimeoutACK = ((n + 1) * TimeoutACK) + (n * TimeoutTX_Packet) + (n * MAX_LBT_WAITING_TIME * MAX_LBT
             -_RETRIES);
                  }
              #endif//PACKET_FORWARDING_SUPPORTED
1621   1      #endif//EXTENDED_PACKET_FORMAT
1622   1      
1623   1      }
1624          //------------------------------------------------------------------------------------------------
1625          // Function Name: initForwardedPacketTable
1626          //                                              This function resets the forwarding table.
1627          // Return Value : None
1628          // Parameters   : None
1629          //------------------------------------------------------------------------------------------------
1630          #ifdef PACKET_FORWARDING_SUPPORTED
              void initForwardedPacketTable (void)
              {
                 U8 i;
                 for (i = 0; i < FORWARDED_PACKET_TABLE_SIZE; i++)
                 {
                     ForwardedPacketTable[i].sid = 0xFF;
                     ForwardedPacketTable[i].seq = 0xFF;
                     ForwardedPacketTable[i].chan = 0xFF;
                 }
              }
              #endif
1642          
1643          //------------------------------------------------------------------------------------------------
C51 COMPILER V7.20   EZMACPRO                                                              04/10/2014 16:48:40 PAGE 28  

1644          // Function Name: macSetEnable2
1645          //                                              This function can be use to set the Interrupt Enable2 register of the radio
1646          // Return Value : None
1647          // Parameters   : value - which bit should be set
1648          //------------------------------------------------------------------------------------------------
1649          void macSetEnable2(U8 value)
1650          {
1651   1      
1652   1         if((EZMacProReg.name.LFTMR2 & 0x80)==0x80)
1653   1            value |= SI4432_ENWUT;
1654   1      
1655   1         if((EZMacProReg.name.LBDR & 0x80)==0x80)
1656   1            value |= SI4432_ENLBDI;
1657   1      
1658   1         macSpiWriteReg(SI4432_INTERRUPT_ENABLE_2, value);
1659   1      }
1660          //------------------------------------------------------------------------------------------------
1661          // Function Name: macSetFunction1
1662          //                                              This function can be use to set the Operation Function Control1 register of the radio
1663          // Return Value : None
1664          // Parameters   : value -which bit should be set
1665          //
1666          //------------------------------------------------------------------------------------------------
1667          void macSetFunction1(U8 value)
1668          {
1669   1      
1670   1         if((EZMacProReg.name.LFTMR2 & 0x80)==0x80)
1671   1            value |= SI4432_ENWT;
1672   1      
1673   1         if((EZMacProReg.name.LFTMR2 & 0x40)==0x00)
1674   1            value |= SI4432_X32KSEL;
1675   1      
1676   1         if((EZMacProReg.name.LBDR & 0x80)==0x80)
1677   1            value |= SI4432_ENLBD;
1678   1      
1679   1         macSpiWriteReg(SI4432_OPERATING_AND_FUNCTION_CONTROL_1, value);
1680   1      }
1681          //------------------------------------------------------------------------------------------------
1682          // Function Name: macUpdateLBTI
1683          //                                              This function update the Listen Before Talk timeout.
1684          //
1685          // Return Value : None
1686          // Parameters   : lbti - Listen Before Talk Interval Register value
1687          //
1688          //------------------------------------------------------------------------------------------------
1689          
1690          #ifdef   TRANSCEIVER_OPERATION
1691          void macUpdateLBTI (U8 lbti)
1692          {
1693   1         U8 rate;
1694   1      
1695   1         // check fixed or byte time LBT
1696   1         if((lbti & 0x80) == 0x80)
1697   1         {
1698   2          // set timeout to 100 us
1699   2          TimeoutLBTI = TIMEOUT_US(100);
1700   2         }
1701   1         else
1702   1         {
1703   2          // get data rate from MCR
1704   2          rate = ((EZMacProReg.name.MCR >> 5)&0x03);
1705   2          //look-up byte time
C51 COMPILER V7.20   EZMACPRO                                                              04/10/2014 16:48:40 PAGE 29  

1706   2          TimeoutLBTI = EZMacProByteTime[rate];
1707   2         }
1708   1      
1709   1         // multiply by LBTI register
1710   1         TimeoutLBTI *= (U32)(lbti& 0x7F);
1711   1      }
1712          #endif //TRANSCEIVER_OPERATION
1713          
1714          
1715          //================================================================================================
1716          // end EZMacPro.c
1717          //================================================================================================


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3337    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     80    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     33      32
   IDATA SIZE       =     38    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
